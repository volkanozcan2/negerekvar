/*!
 * pixi-filters - v2.6.1
 * Compiled Fri, 11 May 2018 14:16:38 UTC
 *
 * pixi-filters is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var __filters=function(r,e){"use strict";var t="attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n    vTextureCoord = aTextureCoord;\r\n}",n="varying vec2 vTextureCoord;\r\nuniform sampler2D uSampler;\r\n\r\nuniform float gamma;\r\nuniform float contrast;\r\nuniform float saturation;\r\nuniform float brightness;\r\nuniform float red;\r\nuniform float green;\r\nuniform float blue;\r\nuniform float alpha;\r\n\r\nvoid main(void)\r\n{\r\n    vec4 c = texture2D(uSampler, vTextureCoord);\r\n\r\n    if (c.a > 0.0) {\r\n        c.rgb /= c.a;\r\n\r\n        vec3 rgb = pow(c.rgb, vec3(1. / gamma));\r\n        rgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb)), rgb, saturation), contrast);\r\n        rgb.r *= red;\r\n        rgb.g *= green;\r\n        rgb.b *= blue;\r\n        c.rgb = rgb * brightness;\r\n\r\n        c.rgb *= c.a;\r\n    }\r\n\r\n    gl_FragColor = c * alpha;\r\n}\r\n",o=function(r){function e(e){r.call(this,t,n),Object.assign(this,{gamma:1,saturation:1,contrast:1,brightness:1,red:1,green:1,blue:1,alpha:1},e)}return r&&(e.__proto__=r),e.prototype=Object.create(r&&r.prototype),e.prototype.constructor=e,e.prototype.apply=function(r,e,t,n){this.uniforms.gamma=Math.max(this.gamma,1e-4),this.uniforms.saturation=this.saturation,this.uniforms.contrast=this.contrast,this.uniforms.brightness=this.brightness,this.uniforms.red=this.red,this.uniforms.green=this.green,this.uniforms.blue=this.blue,this.uniforms.alpha=this.alpha,r.applyFilter(this,e,t,n)},e}(e.Filter),i="attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n    vTextureCoord = aTextureCoord;\r\n}",a="\r\nvarying vec2 vTextureCoord;\r\nuniform sampler2D uSampler;\r\n\r\nuniform vec2 uOffset;\r\n\r\nvoid main(void)\r\n{\r\n    vec4 color = vec4(0.0);\r\n\r\n    // Sample top left pixel\r\n    color += texture2D(uSampler, vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y + uOffset.y));\r\n\r\n    // Sample top right pixel\r\n    color += texture2D(uSampler, vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y + uOffset.y));\r\n\r\n    // Sample bottom right pixel\r\n    color += texture2D(uSampler, vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y - uOffset.y));\r\n\r\n    // Sample bottom left pixel\r\n    color += texture2D(uSampler, vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y - uOffset.y));\r\n\r\n    // Average\r\n    color *= 0.25;\r\n\r\n    gl_FragColor = color;\r\n}",l="\r\nvarying vec2 vTextureCoord;\r\nuniform sampler2D uSampler;\r\n\r\nuniform vec2 uOffset;\r\nuniform vec4 filterClamp;\r\n\r\nvoid main(void)\r\n{\r\n    vec4 color = vec4(0.0);\r\n\r\n    // Sample top left pixel\r\n    color += texture2D(uSampler, clamp(vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y + uOffset.y), filterClamp.xy, filterClamp.zw));\r\n\r\n    // Sample top right pixel\r\n    color += texture2D(uSampler, clamp(vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y + uOffset.y), filterClamp.xy, filterClamp.zw));\r\n\r\n    // Sample bottom right pixel\r\n    color += texture2D(uSampler, clamp(vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y - uOffset.y), filterClamp.xy, filterClamp.zw));\r\n\r\n    // Sample bottom left pixel\r\n    color += texture2D(uSampler, clamp(vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y - uOffset.y), filterClamp.xy, filterClamp.zw));\r\n\r\n    // Average\r\n    color *= 0.25;\r\n\r\n    gl_FragColor = color;\r\n}\r\n",s=function(r){function t(t,n,o){void 0===t&&(t=4),void 0===n&&(n=3),void 0===o&&(o=!1),r.call(this,i,o?l:a),this.uniforms.uOffset=new Float32Array(2),this._pixelSize=new e.Point,this.pixelSize=1,this._clamp=o,this._kernels=null,Array.isArray(t)?this.kernels=t:(this._blur=t,this.quality=n)}r&&(t.__proto__=r),t.prototype=Object.create(r&&r.prototype),t.prototype.constructor=t;var n={kernels:{configurable:!0},clamp:{configurable:!0},pixelSize:{configurable:!0},quality:{configurable:!0},blur:{configurable:!0}};return t.prototype.apply=function(r,e,t,n){var o,i=this.pixelSize.x/e.size.width,a=this.pixelSize.y/e.size.height;if(1===this._quality||0===this._blur)o=this._kernels[0]+.5,this.uniforms.uOffset[0]=o*i,this.uniforms.uOffset[1]=o*a,r.applyFilter(this,e,t,n);else{for(var l,s=r.getRenderTarget(!0),u=e,c=s,f=this._quality-1,d=0;d<f;d++)o=this._kernels[d]+.5,this.uniforms.uOffset[0]=o*i,this.uniforms.uOffset[1]=o*a,r.applyFilter(this,u,c,!0),l=u,u=c,c=l;o=this._kernels[f]+.5,this.uniforms.uOffset[0]=o*i,this.uniforms.uOffset[1]=o*a,r.applyFilter(this,u,t,n),r.returnRenderTarget(s)}},t.prototype._generateKernels=function(){var r=this._blur,e=this._quality,t=[r];if(r>0)for(var n=r,o=r/e,i=1;i<e;i++)n-=o,t.push(n);this._kernels=t},n.kernels.get=function(){return this._kernels},n.kernels.set=function(r){Array.isArray(r)&&r.length>0?(this._kernels=r,this._quality=r.length,this._blur=Math.max.apply(Math,r)):(this._kernels=[0],this._quality=1)},n.clamp.get=function(){return this._clamp},n.pixelSize.set=function(r){"number"==typeof r?(this._pixelSize.x=r,this._pixelSize.y=r):Array.isArray(r)?(this._pixelSize.x=r[0],this._pixelSize.y=r[1]):r instanceof e.Point?(this._pixelSize.x=r.x,this._pixelSize.y=r.y):(this._pixelSize.x=1,this._pixelSize.y=1)},n.pixelSize.get=function(){return this._pixelSize},n.quality.get=function(){return this._quality},n.quality.set=function(r){this._quality=Math.max(1,Math.round(r)),this._generateKernels()},n.blur.get=function(){return this._blur},n.blur.set=function(r){this._blur=r,this._generateKernels()},Object.defineProperties(t.prototype,n),t}(e.Filter),u="attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n    vTextureCoord = aTextureCoord;\r\n}",c="\r\nuniform sampler2D uSampler;\r\nvarying vec2 vTextureCoord;\r\n\r\nuniform float threshold;\r\n\r\nvoid main() {\r\n    vec4 color = texture2D(uSampler, vTextureCoord);\r\n\r\n    // A simple & fast algorithm for getting brightness.\r\n    // It's inaccuracy , but good enought for this feature.\r\n    float _max = max(max(color.r, color.g), color.b);\r\n    float _min = min(min(color.r, color.g), color.b);\r\n    float brightness = (_max + _min) * 0.5;\r\n\r\n    if(brightness > threshold) {\r\n        gl_FragColor = color;\r\n    } else {\r\n        gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\r\n    }\r\n}\r\n",f=function(r){function e(e){void 0===e&&(e=.5),r.call(this,u,c),this.threshold=e}r&&(e.__proto__=r),e.prototype=Object.create(r&&r.prototype),e.prototype.constructor=e;var t={threshold:{configurable:!0}};return t.threshold.get=function(){return this.uniforms.threshold},t.threshold.set=function(r){this.uniforms.threshold=r},Object.defineProperties(e.prototype,t),e}(e.Filter),d="uniform sampler2D uSampler;\r\nvarying vec2 vTextureCoord;\r\n\r\nuniform sampler2D bloomTexture;\r\nuniform float bloomScale;\r\nuniform float brightness;\r\n\r\nvoid main() {\r\n    vec4 color = texture2D(uSampler, vTextureCoord);\r\n    color.rgb *= brightness;\r\n    vec4 bloomColor = vec4(texture2D(bloomTexture, vTextureCoord).rgb, 0.0);\r\n    bloomColor.rgb *= bloomScale;\r\n    gl_FragColor = color + bloomColor;\r\n}\r\n",p=function(r){function t(t){r.call(this,u,d),"number"==typeof t&&(t={threshold:t}),t=Object.assign({threshold:.5,bloomScale:1,brightness:1,kernels:null,blur:8,quality:4,pixelSize:1,resolution:e.settings.RESOLUTION},t),this.bloomScale=t.bloomScale,this.brightness=t.brightness;var n=t.kernels,o=t.blur,i=t.quality,a=t.pixelSize,l=t.resolution;this._extractFilter=new f(t.threshold),this._extractFilter.resolution=l,this._blurFilter=n?new s(n):new s(o,i),this.pixelSize=a,this.resolution=l}r&&(t.__proto__=r),t.prototype=Object.create(r&&r.prototype),t.prototype.constructor=t;var n={resolution:{configurable:!0},threshold:{configurable:!0},kernels:{configurable:!0},blur:{configurable:!0},quality:{configurable:!0},pixelSize:{configurable:!0}};return t.prototype.apply=function(r,e,t,n,o){var i=r.getRenderTarget(!0);this._extractFilter.apply(r,e,i,!0,o);var a=r.getRenderTarget(!0);this._blurFilter.apply(r,i,a,!0,o),this.uniforms.bloomScale=this.bloomScale,this.uniforms.brightness=this.brightness,this.uniforms.bloomTexture=a,r.applyFilter(this,e,t,n),r.returnRenderTarget(a),r.returnRenderTarget(i)},n.resolution.get=function(){return this._resolution},n.resolution.set=function(r){this._resolution=r,this._extractFilter&&(this._extractFilter.resolution=r),this._blurFilter&&(this._blurFilter.resolution=r)},n.threshold.get=function(){return this._extractFilter.threshold},n.threshold.set=function(r){this._extractFilter.threshold=r},n.kernels.get=function(){return this._blurFilter.kernels},n.kernels.set=function(r){this._blurFilter.kernels=r},n.blur.get=function(){return this._blurFilter.blur},n.blur.set=function(r){this._blurFilter.blur=r},n.quality.get=function(){return this._blurFilter.quality},n.quality.set=function(r){this._blurFilter.quality=r},n.pixelSize.get=function(){return this._blurFilter.pixelSize},n.pixelSize.set=function(r){this._blurFilter.pixelSize=r},Object.defineProperties(t.prototype,n),t}(e.Filter),h="attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n    vTextureCoord = aTextureCoord;\r\n}",m="varying vec2 vTextureCoord;\r\n\r\nuniform vec4 filterArea;\r\nuniform float pixelSize;\r\nuniform sampler2D uSampler;\r\n\r\nvec2 mapCoord( vec2 coord )\r\n{\r\n    coord *= filterArea.xy;\r\n    coord += filterArea.zw;\r\n\r\n    return coord;\r\n}\r\n\r\nvec2 unmapCoord( vec2 coord )\r\n{\r\n    coord -= filterArea.zw;\r\n    coord /= filterArea.xy;\r\n\r\n    return coord;\r\n}\r\n\r\nvec2 pixelate(vec2 coord, vec2 size)\r\n{\r\n    return floor( coord / size ) * size;\r\n}\r\n\r\nvec2 getMod(vec2 coord, vec2 size)\r\n{\r\n    return mod( coord , size) / size;\r\n}\r\n\r\nfloat character(float n, vec2 p)\r\n{\r\n    p = floor(p*vec2(4.0, -4.0) + 2.5);\r\n    if (clamp(p.x, 0.0, 4.0) == p.x && clamp(p.y, 0.0, 4.0) == p.y)\r\n    {\r\n        if (int(mod(n/exp2(p.x + 5.0*p.y), 2.0)) == 1) return 1.0;\r\n    }\r\n    return 0.0;\r\n}\r\n\r\nvoid main()\r\n{\r\n    vec2 coord = mapCoord(vTextureCoord);\r\n\r\n    // get the rounded color..\r\n    vec2 pixCoord = pixelate(coord, vec2(pixelSize));\r\n    pixCoord = unmapCoord(pixCoord);\r\n\r\n    vec4 color = texture2D(uSampler, pixCoord);\r\n\r\n    // determine the character to use\r\n    float gray = (color.r + color.g + color.b) / 3.0;\r\n\r\n    float n =  65536.0;             // .\r\n    if (gray > 0.2) n = 65600.0;    // :\r\n    if (gray > 0.3) n = 332772.0;   // *\r\n    if (gray > 0.4) n = 15255086.0; // o\r\n    if (gray > 0.5) n = 23385164.0; // &\r\n    if (gray > 0.6) n = 15252014.0; // 8\r\n    if (gray > 0.7) n = 13199452.0; // @\r\n    if (gray > 0.8) n = 11512810.0; // #\r\n\r\n    // get the mod..\r\n    vec2 modd = getMod(coord, vec2(pixelSize));\r\n\r\n    gl_FragColor = color * character( n, vec2(-1.0) + modd * 2.0);\r\n\r\n}",g=function(r){function e(e){void 0===e&&(e=8),r.call(this,h,m),this.size=e}r&&(e.__proto__=r),e.prototype=Object.create(r&&r.prototype),e.prototype.constructor=e;var t={size:{configurable:!0}};return t.size.get=function(){return this.uniforms.pixelSize},t.size.set=function(r){this.uniforms.pixelSize=r},Object.defineProperties(e.prototype,t),e}(e.Filter),v="attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n    vTextureCoord = aTextureCoord;\r\n}",x="precision mediump float;\r\n\r\nvarying vec2 vTextureCoord;\r\nuniform sampler2D uSampler;\r\nuniform vec4 filterArea;\r\n\r\nuniform float transformX;\r\nuniform float transformY;\r\nuniform vec3 lightColor;\r\nuniform float lightAlpha;\r\nuniform vec3 shadowColor;\r\nuniform float shadowAlpha;\r\n\r\nvoid main(void) {\r\n    vec2 transform = vec2(1.0 / filterArea) * vec2(transformX, transformY);\r\n    vec4 color = texture2D(uSampler, vTextureCoord);\r\n    float light = texture2D(uSampler, vTextureCoord - transform).a;\r\n    float shadow = texture2D(uSampler, vTextureCoord + transform).a;\r\n\r\n    color.rgb = mix(color.rgb, lightColor, clamp((color.a - light) * lightAlpha, 0.0, 1.0));\r\n    color.rgb = mix(color.rgb, shadowColor, clamp((color.a - shadow) * shadowAlpha, 0.0, 1.0));\r\n    gl_FragColor = vec4(color.rgb * color.a, color.a);\r\n}\r\n",y=function(r){function t(e){void 0===e&&(e={}),r.call(this,v,x),this.uniforms.lightColor=new Float32Array(3),this.uniforms.shadowColor=new Float32Array(3),e=Object.assign({rotation:45,thickness:2,lightColor:16777215,lightAlpha:.7,shadowColor:0,shadowAlpha:.7},e),this.rotation=e.rotation,this.thickness=e.thickness,this.lightColor=e.lightColor,this.lightAlpha=e.lightAlpha,this.shadowColor=e.shadowColor,this.shadowAlpha=e.shadowAlpha}r&&(t.__proto__=r),t.prototype=Object.create(r&&r.prototype),t.prototype.constructor=t;var n={rotation:{configurable:!0},thickness:{configurable:!0},lightColor:{configurable:!0},lightAlpha:{configurable:!0},shadowColor:{configurable:!0},shadowAlpha:{configurable:!0}};return t.prototype._updateTransform=function(){this.uniforms.transformX=this._thickness*Math.cos(this._angle),this.uniforms.transformY=this._thickness*Math.sin(this._angle)},n.rotation.get=function(){return this._angle/e.DEG_TO_RAD},n.rotation.set=function(r){this._angle=r*e.DEG_TO_RAD,this._updateTransform()},n.thickness.get=function(){return this._thickness},n.thickness.set=function(r){this._thickness=r,this._updateTransform()},n.lightColor.get=function(){return e.utils.rgb2hex(this.uniforms.lightColor)},n.lightColor.set=function(r){e.utils.hex2rgb(r,this.uniforms.lightColor)},n.lightAlpha.get=function(){return this.uniforms.lightAlpha},n.lightAlpha.set=function(r){this.uniforms.lightAlpha=r},n.shadowColor.get=function(){return e.utils.rgb2hex(this.uniforms.shadowColor)},n.shadowColor.set=function(r){e.utils.hex2rgb(r,this.uniforms.shadowColor)},n.shadowAlpha.get=function(){return this.uniforms.shadowAlpha},n.shadowAlpha.set=function(r){this.uniforms.shadowAlpha=r},Object.defineProperties(t.prototype,n),t}(e.Filter),b=e.filters,_=b.BlurXFilter,C=b.BlurYFilter,S=b.AlphaFilter,T=function(r){function t(t,n,o,i){var a,l;void 0===t&&(t=2),void 0===n&&(n=4),void 0===o&&(o=e.settings.RESOLUTION),void 0===i&&(i=5),r.call(this),"number"==typeof t?(a=t,l=t):t instanceof e.Point?(a=t.x,l=t.y):Array.isArray(t)&&(a=t[0],l=t[1]),this.blurXFilter=new _(a,n,o,i),this.blurYFilter=new C(l,n,o,i),this.blurYFilter.blendMode=e.BLEND_MODES.SCREEN,this.defaultFilter=new S}r&&(t.__proto__=r),t.prototype=Object.create(r&&r.prototype),t.prototype.constructor=t;var n={blur:{configurable:!0},blurX:{configurable:!0},blurY:{configurable:!0}};return t.prototype.apply=function(r,e,t){var n=r.getRenderTarget(!0);this.defaultFilter.apply(r,e,t),this.blurXFilter.apply(r,e,n),this.blurYFilter.apply(r,n,t),r.returnRenderTarget(n)},n.blur.get=function(){return this.blurXFilter.blur},n.blur.set=function(r){this.blurXFilter.blur=this.blurYFilter.blur=r},n.blurX.get=function(){return this.blurXFilter.blur},n.blurX.set=function(r){this.blurXFilter.blur=r},n.blurY.get=function(){return this.blurYFilter.blur},n.blurY.set=function(r){this.blurYFilter.blur=r},Object.defineProperties(t.prototype,n),t}(e.Filter),F="attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n    vTextureCoord = aTextureCoord;\r\n}",z="uniform float radius;\r\nuniform float strength;\r\nuniform vec2 center;\r\nuniform sampler2D uSampler;\r\nvarying vec2 vTextureCoord;\r\n\r\nuniform vec4 filterArea;\r\nuniform vec4 filterClamp;\r\nuniform vec2 dimensions;\r\n\r\nvoid main()\r\n{\r\n    vec2 coord = vTextureCoord * filterArea.xy;\r\n    coord -= center * dimensions.xy;\r\n    float distance = length(coord);\r\n    if (distance < radius) {\r\n        float percent = distance / radius;\r\n        if (strength > 0.0) {\r\n            coord *= mix(1.0, smoothstep(0.0, radius / distance, percent), strength * 0.75);\r\n        } else {\r\n            coord *= mix(1.0, pow(percent, 1.0 + strength * 0.75) * radius / distance, 1.0 - percent);\r\n        }\r\n    }\r\n    coord += center * dimensions.xy;\r\n    coord /= filterArea.xy;\r\n    vec2 clampedCoord = clamp(coord, filterClamp.xy, filterClamp.zw);\r\n    vec4 color = texture2D(uSampler, clampedCoord);\r\n    if (coord != clampedCoord) {\r\n        color *= max(0.0, 1.0 - length(coord - clampedCoord));\r\n    }\r\n\r\n    gl_FragColor = color;\r\n}\r\n",A=function(r){function e(e,t,n){r.call(this,F,z),this.uniforms.dimensions=new Float32Array(2),this.center=e||[.5,.5],this.radius=t||100,this.strength=n||1}r&&(e.__proto__=r),e.prototype=Object.create(r&&r.prototype),e.prototype.constructor=e;var t={radius:{configurable:!0},strength:{configurable:!0},center:{configurable:!0}};return e.prototype.apply=function(r,e,t,n){this.uniforms.dimensions[0]=e.sourceFrame.width,this.uniforms.dimensions[1]=e.sourceFrame.height,r.applyFilter(this,e,t,n)},t.radius.get=function(){return this.uniforms.radius},t.radius.set=function(r){this.uniforms.radius=r},t.strength.get=function(){return this.uniforms.strength},t.strength.set=function(r){this.uniforms.strength=r},t.center.get=function(){return this.uniforms.center},t.center.set=function(r){this.uniforms.center=r},Object.defineProperties(e.prototype,t),e}(e.Filter),w="attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n    vTextureCoord = aTextureCoord;\r\n}",P="\r\nvarying vec2 vTextureCoord;\r\nuniform sampler2D uSampler;\r\n\r\nuniform sampler2D colorMap;\r\n\r\nuniform float _mix;\r\nuniform float _size;\r\nuniform float _sliceSize;\r\nuniform float _slicePixelSize;\r\nuniform float _sliceInnerSize;\r\n\r\nvoid main() {\r\n    vec4 color = texture2D(uSampler, vTextureCoord.xy);\r\n\r\n    float sliceIndex = color.b * (_size - 1.0);\r\n    float zSlice0 = floor(sliceIndex);\r\n    float zSlice1 = ceil(sliceIndex);\r\n\r\n    float xOffset = _slicePixelSize * 0.5 + color.r * _sliceInnerSize;\r\n    float s0 = xOffset + zSlice0 * _sliceSize;\r\n    float s1 = xOffset + zSlice1 * _sliceSize;\r\n    vec4 slice0Color = texture2D(colorMap, vec2(s0, color.g));\r\n    vec4 slice1Color = texture2D(colorMap, vec2(s1, color.g));\r\n    vec4 adjusted = mix(slice0Color, slice1Color, fract(sliceIndex));\r\n\r\n    gl_FragColor = mix(color, adjusted, _mix);\r\n}\r\n",D=function(r){function t(e,t,n){void 0===t&&(t=!1),void 0===n&&(n=1),r.call(this,w,P),this._size=0,this._sliceSize=0,this._slicePixelSize=0,this._sliceInnerSize=0,this._scaleMode=null,this._nearest=!1,this.nearest=t,this.mix=n,this.colorMap=e}r&&(t.__proto__=r),t.prototype=Object.create(r&&r.prototype),t.prototype.constructor=t;var n={colorSize:{configurable:!0},colorMap:{configurable:!0},nearest:{configurable:!0}};return t.prototype.apply=function(r,e,t,n){this.uniforms._mix=this.mix,r.applyFilter(this,e,t,n)},n.colorSize.get=function(){return this._size},n.colorMap.get=function(){return this._colorMap},n.colorMap.set=function(r){r instanceof e.Texture||(r=e.Texture.from(r)),r&&r.baseTexture&&(r.baseTexture.scaleMode=this._scaleMode,r.baseTexture.mipmap=!1,this._size=r.height,this._sliceSize=1/this._size,this._slicePixelSize=this._sliceSize/this._size,this._sliceInnerSize=this._slicePixelSize*(this._size-1),this.uniforms._size=this._size,this.uniforms._sliceSize=this._sliceSize,this.uniforms._slicePixelSize=this._slicePixelSize,this.uniforms._sliceInnerSize=this._sliceInnerSize,this.uniforms.colorMap=r),this._colorMap=r},n.nearest.get=function(){return this._nearest},n.nearest.set=function(r){this._nearest=r,this._scaleMode=r?e.SCALE_MODES.NEAREST:e.SCALE_MODES.LINEAR;var t=this._colorMap;t&&t.baseTexture&&(t.baseTexture._glTextures={},t.baseTexture.scaleMode=this._scaleMode,t.baseTexture.mipmap=!1,t._updateID++,t.baseTexture.emit("update",t.baseTexture))},t.prototype.updateColorMap=function(){var r=this._colorMap;r&&r.baseTexture&&(r._updateID++,r.baseTexture.emit("update",r.baseTexture),this.colorMap=r)},t.prototype.destroy=function(e){this._colorMap&&this._colorMap.destroy(e),r.prototype.destroy.call(this)},Object.defineProperties(t.prototype,n),t}(e.Filter),M="attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n    vTextureCoord = aTextureCoord;\r\n}",O="varying vec2 vTextureCoord;\r\nuniform sampler2D uSampler;\r\nuniform vec3 originalColor;\r\nuniform vec3 newColor;\r\nuniform float epsilon;\r\nvoid main(void) {\r\n    vec4 currentColor = texture2D(uSampler, vTextureCoord);\r\n    vec3 colorDiff = originalColor - (currentColor.rgb / max(currentColor.a, 0.0000000001));\r\n    float colorDistance = length(colorDiff);\r\n    float doReplace = step(colorDistance, epsilon);\r\n    gl_FragColor = vec4(mix(currentColor.rgb, (newColor + colorDiff) * currentColor.a, doReplace), currentColor.a);\r\n}\r\n",j=function(r){function t(e,t,n){void 0===e&&(e=16711680),void 0===t&&(t=0),void 0===n&&(n=.4),r.call(this,M,O),this.uniforms.originalColor=new Float32Array(3),this.uniforms.newColor=new Float32Array(3),this.originalColor=e,this.newColor=t,this.epsilon=n}r&&(t.__proto__=r),t.prototype=Object.create(r&&r.prototype),t.prototype.constructor=t;var n={originalColor:{configurable:!0},newColor:{configurable:!0},epsilon:{configurable:!0}};return n.originalColor.set=function(r){var t=this.uniforms.originalColor;"number"==typeof r?(e.utils.hex2rgb(r,t),this._originalColor=r):(t[0]=r[0],t[1]=r[1],t[2]=r[2],this._originalColor=e.utils.rgb2hex(t))},n.originalColor.get=function(){return this._originalColor},n.newColor.set=function(r){var t=this.uniforms.newColor;"number"==typeof r?(e.utils.hex2rgb(r,t),this._newColor=r):(t[0]=r[0],t[1]=r[1],t[2]=r[2],this._newColor=e.utils.rgb2hex(t))},n.newColor.get=function(){return this._newColor},n.epsilon.set=function(r){this.uniforms.epsilon=r},n.epsilon.get=function(){return this.uniforms.epsilon},Object.defineProperties(t.prototype,n),t}(e.Filter),R="attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n    vTextureCoord = aTextureCoord;\r\n}",L="precision mediump float;\r\n\r\nvarying mediump vec2 vTextureCoord;\r\n\r\nuniform sampler2D uSampler;\r\nuniform vec2 texelSize;\r\nuniform float matrix[9];\r\n\r\nvoid main(void)\r\n{\r\n   vec4 c11 = texture2D(uSampler, vTextureCoord - texelSize); // top left\r\n   vec4 c12 = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - texelSize.y)); // top center\r\n   vec4 c13 = texture2D(uSampler, vec2(vTextureCoord.x + texelSize.x, vTextureCoord.y - texelSize.y)); // top right\r\n\r\n   vec4 c21 = texture2D(uSampler, vec2(vTextureCoord.x - texelSize.x, vTextureCoord.y)); // mid left\r\n   vec4 c22 = texture2D(uSampler, vTextureCoord); // mid center\r\n   vec4 c23 = texture2D(uSampler, vec2(vTextureCoord.x + texelSize.x, vTextureCoord.y)); // mid right\r\n\r\n   vec4 c31 = texture2D(uSampler, vec2(vTextureCoord.x - texelSize.x, vTextureCoord.y + texelSize.y)); // bottom left\r\n   vec4 c32 = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + texelSize.y)); // bottom center\r\n   vec4 c33 = texture2D(uSampler, vTextureCoord + texelSize); // bottom right\r\n\r\n   gl_FragColor =\r\n       c11 * matrix[0] + c12 * matrix[1] + c13 * matrix[2] +\r\n       c21 * matrix[3] + c22 * matrix[4] + c23 * matrix[5] +\r\n       c31 * matrix[6] + c32 * matrix[7] + c33 * matrix[8];\r\n\r\n   gl_FragColor.a = c22.a;\r\n}\r\n",k=function(r){function e(e,t,n){r.call(this,R,L),this.uniforms.texelSize=new Float32Array(9),this.matrix=e,this.width=t,this.height=n}r&&(e.__proto__=r),e.prototype=Object.create(r&&r.prototype),e.prototype.constructor=e;var t={matrix:{configurable:!0},width:{configurable:!0},height:{configurable:!0}};return t.matrix.get=function(){return this.uniforms.matrix},t.matrix.set=function(r){this.uniforms.matrix=new Float32Array(r)},t.width.get=function(){return 1/this.uniforms.texelSize[0]},t.width.set=function(r){this.uniforms.texelSize[0]=1/r},t.height.get=function(){return 1/this.uniforms.texelSize[1]},t.height.set=function(r){this.uniforms.texelSize[1]=1/r},Object.defineProperties(e.prototype,t),e}(e.Filter),I="attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n    vTextureCoord = aTextureCoord;\r\n}",V="precision mediump float;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nuniform sampler2D uSampler;\r\n\r\nvoid main(void)\r\n{\r\n    float lum = length(texture2D(uSampler, vTextureCoord.xy).rgb);\r\n\r\n    gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\r\n\r\n    if (lum < 1.00)\r\n    {\r\n        if (mod(gl_FragCoord.x + gl_FragCoord.y, 10.0) == 0.0)\r\n        {\r\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\r\n        }\r\n    }\r\n\r\n    if (lum < 0.75)\r\n    {\r\n        if (mod(gl_FragCoord.x - gl_FragCoord.y, 10.0) == 0.0)\r\n        {\r\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\r\n        }\r\n    }\r\n\r\n    if (lum < 0.50)\r\n    {\r\n        if (mod(gl_FragCoord.x + gl_FragCoord.y - 5.0, 10.0) == 0.0)\r\n        {\r\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\r\n        }\r\n    }\r\n\r\n    if (lum < 0.3)\r\n    {\r\n        if (mod(gl_FragCoord.x - gl_FragCoord.y - 5.0, 10.0) == 0.0)\r\n        {\r\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\r\n        }\r\n    }\r\n}\r\n",E=function(r){function e(){r.call(this,I,V)}return r&&(e.__proto__=r),e.prototype=Object.create(r&&r.prototype),e.prototype.constructor=e,e}(e.Filter),B="attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n    vTextureCoord = aTextureCoord;\r\n}",X="varying vec2 vTextureCoord;\r\nuniform sampler2D uSampler;\r\n\r\nuniform vec4 filterArea;\r\nuniform vec2 dimensions;\r\n\r\nconst float SQRT_2 = 1.414213;\r\n\r\nconst float light = 1.0;\r\n\r\nuniform float curvature;\r\nuniform float lineWidth;\r\nuniform float lineContrast;\r\nuniform bool verticalLine;\r\nuniform float noise;\r\nuniform float noiseSize;\r\n\r\nuniform float vignetting;\r\nuniform float vignettingAlpha;\r\nuniform float vignettingBlur;\r\n\r\nuniform float seed;\r\nuniform float time;\r\n\r\nfloat rand(vec2 co) {\r\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\r\n}\r\n\r\nvoid main(void)\r\n{\r\n    vec2 pixelCoord = vTextureCoord.xy * filterArea.xy;\r\n    vec2 coord = pixelCoord / dimensions;\r\n\r\n    vec2 dir = vec2(coord - vec2(0.5, 0.5));\r\n\r\n    float _c = curvature > 0. ? curvature : 1.;\r\n    float k = curvature > 0. ?(length(dir * dir) * 0.25 * _c * _c + 0.935 * _c) : 1.;\r\n    vec2 uv = dir * k;\r\n\r\n    gl_FragColor = texture2D(uSampler, vTextureCoord);\r\n    vec3 rgb = gl_FragColor.rgb;\r\n\r\n\r\n    if (noise > 0.0 && noiseSize > 0.0)\r\n    {\r\n        pixelCoord.x = floor(pixelCoord.x / noiseSize);\r\n        pixelCoord.y = floor(pixelCoord.y / noiseSize);\r\n        float _noise = rand(pixelCoord * noiseSize * seed) - 0.5;\r\n        rgb += _noise * noise;\r\n    }\r\n\r\n    if (lineWidth > 0.0) {\r\n        float v = (verticalLine ? uv.x * dimensions.x : uv.y * dimensions.y) * min(1.0, 2.0 / lineWidth ) / _c;\r\n        float j = 1. + cos(v * 1.2 - time) * 0.5 * lineContrast;\r\n        rgb *= j;\r\n        float segment = verticalLine ? mod((dir.x + .5) * dimensions.x, 4.) : mod((dir.y + .5) * dimensions.y, 4.);\r\n        rgb *= 0.99 + ceil(segment) * 0.015;\r\n    }\r\n\r\n    if (vignetting > 0.0)\r\n    {\r\n        float outter = SQRT_2 - vignetting * SQRT_2;\r\n        float darker = clamp((outter - length(dir) * SQRT_2) / ( 0.00001 + vignettingBlur * SQRT_2), 0.0, 1.0);\r\n        rgb *= darker + (1.0 - darker) * (1.0 - vignettingAlpha);\r\n    }\r\n\r\n    gl_FragColor.rgb = rgb;\r\n}\r\n",q=function(r){function e(e){r.call(this,B,X),this.uniforms.dimensions=new Float32Array(2),this.time=0,this.seed=0,Object.assign(this,{curvature:1,lineWidth:1,lineContrast:.25,verticalLine:!1,noise:0,noiseSize:1,seed:0,vignetting:.3,vignettingAlpha:1,vignettingBlur:.3,time:0},e)}r&&(e.__proto__=r),e.prototype=Object.create(r&&r.prototype),e.prototype.constructor=e;var t={curvature:{configurable:!0},lineWidth:{configurable:!0},lineContrast:{configurable:!0},verticalLine:{configurable:!0},noise:{configurable:!0},noiseSize:{configurable:!0},vignetting:{configurable:!0},vignettingAlpha:{configurable:!0},vignettingBlur:{configurable:!0}};return e.prototype.apply=function(r,e,t,n){this.uniforms.dimensions[0]=e.sourceFrame.width,this.uniforms.dimensions[1]=e.sourceFrame.height,this.uniforms.seed=this.seed,this.uniforms.time=this.time,r.applyFilter(this,e,t,n)},t.curvature.set=function(r){this.uniforms.curvature=r},t.curvature.get=function(){return this.uniforms.curvature},t.lineWidth.set=function(r){this.uniforms.lineWidth=r},t.lineWidth.get=function(){return this.uniforms.lineWidth},t.lineContrast.set=function(r){this.uniforms.lineContrast=r},t.lineContrast.get=function(){return this.uniforms.lineContrast},t.verticalLine.set=function(r){this.uniforms.verticalLine=r},t.verticalLine.get=function(){return this.uniforms.verticalLine},t.noise.set=function(r){this.uniforms.noise=r},t.noise.get=function(){return this.uniforms.noise},t.noiseSize.set=function(r){this.uniforms.noiseSize=r},t.noiseSize.get=function(){return this.uniforms.noiseSize},t.vignetting.set=function(r){this.uniforms.vignetting=r},t.vignetting.get=function(){return this.uniforms.vignetting},t.vignettingAlpha.set=function(r){this.uniforms.vignettingAlpha=r},t.vignettingAlpha.get=function(){return this.uniforms.vignettingAlpha},t.vignettingBlur.set=function(r){this.uniforms.vignettingBlur=r},t.vignettingBlur.get=function(){return this.uniforms.vignettingBlur},Object.defineProperties(e.prototype,t),e}(e.Filter),N="attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n    vTextureCoord = aTextureCoord;\r\n}",G="precision mediump float;\r\n\r\nvarying vec2 vTextureCoord;\r\nvarying vec4 vColor;\r\n\r\nuniform vec4 filterArea;\r\nuniform sampler2D uSampler;\r\n\r\nuniform float angle;\r\nuniform float scale;\r\n\r\nfloat pattern()\r\n{\r\n   float s = sin(angle), c = cos(angle);\r\n   vec2 tex = vTextureCoord * filterArea.xy;\r\n   vec2 point = vec2(\r\n       c * tex.x - s * tex.y,\r\n       s * tex.x + c * tex.y\r\n   ) * scale;\r\n   return (sin(point.x) * sin(point.y)) * 4.0;\r\n}\r\n\r\nvoid main()\r\n{\r\n   vec4 color = texture2D(uSampler, vTextureCoord);\r\n   float average = (color.r + color.g + color.b) / 3.0;\r\n   gl_FragColor = vec4(vec3(average * 10.0 - 5.0 + pattern()), color.a);\r\n}\r\n",K=function(r){function e(e,t){void 0===e&&(e=1),void 0===t&&(t=5),r.call(this,N,G),this.scale=e,this.angle=t}r&&(e.__proto__=r),e.prototype=Object.create(r&&r.prototype),e.prototype.constructor=e;var t={scale:{configurable:!0},angle:{configurable:!0}};return t.scale.get=function(){return this.uniforms.scale},t.scale.set=function(r){this.uniforms.scale=r},t.angle.get=function(){return this.uniforms.angle},t.angle.set=function(r){this.uniforms.angle=r},Object.defineProperties(e.prototype,t),e}(e.Filter),Y="attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n    vTextureCoord = aTextureCoord;\r\n}",W="varying vec2 vTextureCoord;\r\nuniform sampler2D uSampler;\r\nuniform float alpha;\r\nuniform vec3 color;\r\nvoid main(void){\r\n    vec4 sample = texture2D(uSampler, vTextureCoord);\r\n\r\n    // Un-premultiply alpha before applying the color\r\n    if (sample.a > 0.0) {\r\n        sample.rgb /= sample.a;\r\n    }\r\n\r\n    // Premultiply alpha again\r\n    sample.rgb = color.rgb * sample.a;\r\n\r\n    // alpha user alpha\r\n    sample *= alpha;\r\n\r\n    gl_FragColor = sample;\r\n}",Q=function(r){function t(t){t&&t.constructor!==Object&&(console.warn("DropShadowFilter now uses options instead of (rotation, distance, blur, color, alpha)"),t={rotation:t},void 0!==arguments[1]&&(t.distance=arguments[1]),void 0!==arguments[2]&&(t.blur=arguments[2]),void 0!==arguments[3]&&(t.color=arguments[3]),void 0!==arguments[4]&&(t.alpha=arguments[4])),t=Object.assign({rotation:45,distance:5,color:0,alpha:.5,shadowOnly:!1,kernels:null,blur:2,quality:3,pixelSize:1,resolution:e.settings.RESOLUTION},t),r.call(this);var n=t.kernels,o=t.blur,i=t.quality,a=t.pixelSize,l=t.resolution;this._tintFilter=new e.Filter(Y,W),this._tintFilter.uniforms.color=new Float32Array(4),this._tintFilter.resolution=l,this._blurFilter=n?new s(n):new s(o,i),this.pixelSize=a,this.resolution=l,this.targetTransform=new e.Matrix;var u=t.shadowOnly,c=t.rotation,f=t.distance,d=t.alpha,p=t.color;this.shadowOnly=u,this.rotation=c,this.distance=f,this.alpha=d,this.color=p,this._updatePadding()}r&&(t.__proto__=r),t.prototype=Object.create(r&&r.prototype),t.prototype.constructor=t;var n={resolution:{configurable:!0},distance:{configurable:!0},rotation:{configurable:!0},alpha:{configurable:!0},color:{configurable:!0},kernels:{configurable:!0},blur:{configurable:!0},quality:{configurable:!0},pixelSize:{configurable:!0}};return t.prototype.apply=function(r,e,t,n){var o=r.getRenderTarget();o.transform=this.targetTransform,this._tintFilter.apply(r,e,o,!0),o.transform=null,this._blurFilter.apply(r,o,t),!0!==this.shadowOnly&&r.applyFilter(this,e,t,n),r.returnRenderTarget(o)},t.prototype._updatePadding=function(){this.padding=this.distance+2*this.blur},t.prototype._updateTargetTransform=function(){this.targetTransform.tx=this.distance*Math.cos(this.angle),this.targetTransform.ty=this.distance*Math.sin(this.angle)},n.resolution.get=function(){return this._resolution},n.resolution.set=function(r){this._resolution=r,this._tintFilter&&(this._tintFilter.resolution=r),this._blurFilter&&(this._blurFilter.resolution=r)},n.distance.get=function(){return this._distance},n.distance.set=function(r){this._distance=r,this._updatePadding(),this._updateTargetTransform()},n.rotation.get=function(){return this.angle/e.DEG_TO_RAD},n.rotation.set=function(r){this.angle=r*e.DEG_TO_RAD,this._updateTargetTransform()},n.alpha.get=function(){return this._tintFilter.uniforms.alpha},n.alpha.set=function(r){this._tintFilter.uniforms.alpha=r},n.color.get=function(){return e.utils.rgb2hex(this._tintFilter.uniforms.color)},n.color.set=function(r){e.utils.hex2rgb(r,this._tintFilter.uniforms.color)},n.kernels.get=function(){return this._blurFilter.kernels},n.kernels.set=function(r){this._blurFilter.kernels=r},n.blur.get=function(){return this._blurFilter.blur},n.blur.set=function(r){this._blurFilter.blur=r,this._updatePadding()},n.quality.get=function(){return this._blurFilter.quality},n.quality.set=function(r){this._blurFilter.quality=r},n.pixelSize.get=function(){return this._blurFilter.pixelSize},n.pixelSize.set=function(r){this._blurFilter.pixelSize=r},Object.defineProperties(t.prototype,n),t}(e.Filter),U="attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n    vTextureCoord = aTextureCoord;\r\n}",Z="precision mediump float;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nuniform sampler2D uSampler;\r\nuniform float strength;\r\nuniform vec4 filterArea;\r\n\r\n\r\nvoid main(void)\r\n{\r\n\tvec2 onePixel = vec2(1.0 / filterArea);\r\n\r\n\tvec4 color;\r\n\r\n\tcolor.rgb = vec3(0.5);\r\n\r\n\tcolor -= texture2D(uSampler, vTextureCoord - onePixel) * strength;\r\n\tcolor += texture2D(uSampler, vTextureCoord + onePixel) * strength;\r\n\r\n\tcolor.rgb = vec3((color.r + color.g + color.b) / 3.0);\r\n\r\n\tfloat alpha = texture2D(uSampler, vTextureCoord).a;\r\n\r\n\tgl_FragColor = vec4(color.rgb * alpha, alpha);\r\n}\r\n",H=function(r){function e(e){void 0===e&&(e=5),r.call(this,U,Z),this.strength=e}r&&(e.__proto__=r),e.prototype=Object.create(r&&r.prototype),e.prototype.constructor=e;var t={strength:{configurable:!0}};return t.strength.get=function(){return this.uniforms.strength},t.strength.set=function(r){this.uniforms.strength=r},Object.defineProperties(e.prototype,t),e}(e.Filter),$="attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n    vTextureCoord = aTextureCoord;\r\n}",J="// precision highp float;\r\n\r\nvarying vec2 vTextureCoord;\r\nuniform sampler2D uSampler;\r\n\r\nuniform vec4 filterArea;\r\nuniform vec4 filterClamp;\r\nuniform vec2 dimensions;\r\nuniform float aspect;\r\n\r\nuniform sampler2D displacementMap;\r\nuniform float offset;\r\nuniform float sinDir;\r\nuniform float cosDir;\r\nuniform int fillMode;\r\n\r\nuniform float seed;\r\nuniform vec2 red;\r\nuniform vec2 green;\r\nuniform vec2 blue;\r\n\r\nconst int TRANSPARENT = 0;\r\nconst int ORIGINAL = 1;\r\nconst int LOOP = 2;\r\nconst int CLAMP = 3;\r\nconst int MIRROR = 4;\r\n\r\nvoid main(void)\r\n{\r\n    vec2 coord = (vTextureCoord * filterArea.xy) / dimensions;\r\n\r\n    if (coord.x > 1.0 || coord.y > 1.0) {\r\n        return;\r\n    }\r\n\r\n    float cx = coord.x - 0.5;\r\n    float cy = (coord.y - 0.5) * aspect;\r\n    float ny = (-sinDir * cx + cosDir * cy) / aspect + 0.5;\r\n\r\n    // displacementMap: repeat\r\n    // ny = ny > 1.0 ? ny - 1.0 : (ny < 0.0 ? 1.0 + ny : ny);\r\n\r\n    // displacementMap: mirror\r\n    ny = ny > 1.0 ? 2.0 - ny : (ny < 0.0 ? -ny : ny);\r\n\r\n    vec4 dc = texture2D(displacementMap, vec2(0.5, ny));\r\n\r\n    float displacement = (dc.r - dc.g) * (offset / filterArea.x);\r\n\r\n    coord = vTextureCoord + vec2(cosDir * displacement, sinDir * displacement * aspect);\r\n\r\n    if (fillMode == CLAMP) {\r\n        coord = clamp(coord, filterClamp.xy, filterClamp.zw);\r\n    } else {\r\n        if( coord.x > filterClamp.z ) {\r\n            if (fillMode == ORIGINAL) {\r\n                gl_FragColor = texture2D(uSampler, vTextureCoord);\r\n                return;\r\n            } else if (fillMode == LOOP) {\r\n                coord.x -= filterClamp.z;\r\n            } else if (fillMode == MIRROR) {\r\n                coord.x = filterClamp.z * 2.0 - coord.x;\r\n            } else {\r\n                gl_FragColor = vec4(0., 0., 0., 0.);\r\n                return;\r\n            }\r\n        } else if( coord.x < filterClamp.x ) {\r\n            if (fillMode == ORIGINAL) {\r\n                gl_FragColor = texture2D(uSampler, vTextureCoord);\r\n                return;\r\n            } else if (fillMode == LOOP) {\r\n                coord.x += filterClamp.z;\r\n            } else if (fillMode == MIRROR) {\r\n                coord.x *= -filterClamp.z;\r\n            } else {\r\n                gl_FragColor = vec4(0., 0., 0., 0.);\r\n                return;\r\n            }\r\n        }\r\n\r\n        if( coord.y > filterClamp.w ) {\r\n            if (fillMode == ORIGINAL) {\r\n                gl_FragColor = texture2D(uSampler, vTextureCoord);\r\n                return;\r\n            } else if (fillMode == LOOP) {\r\n                coord.y -= filterClamp.w;\r\n            } else if (fillMode == MIRROR) {\r\n                coord.y = filterClamp.w * 2.0 - coord.y;\r\n            } else {\r\n                gl_FragColor = vec4(0., 0., 0., 0.);\r\n                return;\r\n            }\r\n        } else if( coord.y < filterClamp.y ) {\r\n            if (fillMode == ORIGINAL) {\r\n                gl_FragColor = texture2D(uSampler, vTextureCoord);\r\n                return;\r\n            } else if (fillMode == LOOP) {\r\n                coord.y += filterClamp.w;\r\n            } else if (fillMode == MIRROR) {\r\n                coord.y *= -filterClamp.w;\r\n            } else {\r\n                gl_FragColor = vec4(0., 0., 0., 0.);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    gl_FragColor.r = texture2D(uSampler, coord + red * (1.0 - seed * 0.4) / filterArea.xy).r;\r\n    gl_FragColor.g = texture2D(uSampler, coord + green * (1.0 - seed * 0.3) / filterArea.xy).g;\r\n    gl_FragColor.b = texture2D(uSampler, coord + blue * (1.0 - seed * 0.2) / filterArea.xy).b;\r\n    gl_FragColor.a = texture2D(uSampler, coord).a;\r\n}\r\n",rr=function(r){function t(t){void 0===t&&(t={}),r.call(this,$,J),this.uniforms.dimensions=new Float32Array(2),t=Object.assign({slices:5,offset:100,direction:0,fillMode:0,average:!1,seed:0,red:[0,0],green:[0,0],blue:[0,0],minSize:8,sampleSize:512},t),this.direction=t.direction,this.red=t.red,this.green=t.green,this.blue=t.blue,this.offset=t.offset,this.fillMode=t.fillMode,this.average=t.average,this.seed=t.seed,this.minSize=t.minSize,this.sampleSize=t.sampleSize,this._canvas=document.createElement("canvas"),this._canvas.width=4,this._canvas.height=this.sampleSize,this.texture=e.Texture.fromCanvas(this._canvas,e.SCALE_MODES.NEAREST),this._slices=0,this.slices=t.slices}r&&(t.__proto__=r),t.prototype=Object.create(r&&r.prototype),t.prototype.constructor=t;var n={sizes:{configurable:!0},offsets:{configurable:!0},slices:{configurable:!0},direction:{configurable:!0},red:{configurable:!0},green:{configurable:!0},blue:{configurable:!0}};return t.prototype.apply=function(r,e,t,n){var o=e.sourceFrame.width,i=e.sourceFrame.height;this.uniforms.dimensions[0]=o,this.uniforms.dimensions[1]=i,this.uniforms.aspect=i/o,this.uniforms.seed=this.seed,this.uniforms.offset=this.offset,this.uniforms.fillMode=this.fillMode,r.applyFilter(this,e,t,n)},t.prototype._randomizeSizes=function(){var r=this._sizes,e=this._slices-1,t=this.sampleSize,n=Math.min(this.minSize/t,.9/this._slices);if(this.average){for(var o=this._slices,i=1,a=0;a<e;a++){var l=i/(o-a),s=Math.max(l*(1-.6*Math.random()),n);r[a]=s,i-=s}r[e]=i}else{for(var u=1,c=Math.sqrt(1/this._slices),f=0;f<e;f++){var d=Math.max(c*u*Math.random(),n);r[f]=d,u-=d}r[e]=u}this.shuffle()},t.prototype.shuffle=function(){for(var r=this._sizes,e=this._slices-1;e>0;e--){var t=Math.random()*e>>0,n=r[e];r[e]=r[t],r[t]=n}},t.prototype._randomizeOffsets=function(){for(var r=0;r<this._slices;r++)this._offsets[r]=Math.random()*(Math.random()<.5?-1:1)},t.prototype.refresh=function(){this._randomizeSizes(),this._randomizeOffsets(),this.redraw()},t.prototype.redraw=function(){var r,e=this.sampleSize,t=this.texture,n=this._canvas.getContext("2d");n.clearRect(0,0,8,e);for(var o=0,i=0;i<this._slices;i++){r=Math.floor(256*this._offsets[i]);var a=this._sizes[i]*e,l=r>0?r:0,s=r<0?-r:0;n.fillStyle="rgba("+l+", "+s+", 0, 1)",n.fillRect(0,o>>0,e,a+1>>0),o+=a}t.baseTexture.emit("update",t.baseTexture),this.uniforms.displacementMap=t},n.sizes.set=function(r){for(var e=Math.min(this._slices,r.length),t=0;t<e;t++)this._sizes[t]=r[t]},n.sizes.get=function(){return this._sizes},n.offsets.set=function(r){for(var e=Math.min(this._slices,r.length),t=0;t<e;t++)this._offsets[t]=r[t]},n.offsets.get=function(){return this._offsets},n.slices.get=function(){return this._slices},n.slices.set=function(r){this._slices!==r&&(this._slices=r,this.uniforms.slices=r,this._sizes=this.uniforms.slicesWidth=new Float32Array(r),this._offsets=this.uniforms.slicesOffset=new Float32Array(r),this.refresh())},n.direction.get=function(){return this._direction},n.direction.set=function(r){if(this._direction!==r){this._direction=r;var t=r*e.DEG_TO_RAD;this.uniforms.sinDir=Math.sin(t),this.uniforms.cosDir=Math.cos(t)}},n.red.get=function(){return this.uniforms.red},n.red.set=function(r){this.uniforms.red=r},n.green.get=function(){return this.uniforms.green},n.green.set=function(r){this.uniforms.green=r},n.blue.get=function(){return this.uniforms.blue},n.blue.set=function(r){this.uniforms.blue=r},t.prototype.destroy=function(){this.texture.destroy(!0),this.texture=null,this._canvas=null,this.red=null,this.green=null,this.blue=null,this._sizes=null,this._offsets=null},Object.defineProperties(t.prototype,n),t}(e.Filter);rr.TRANSPARENT=0,rr.ORIGINAL=1,rr.LOOP=2,rr.CLAMP=3,rr.MIRROR=4;var er="attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n    vTextureCoord = aTextureCoord;\r\n}",tr="varying vec2 vTextureCoord;\r\nvarying vec4 vColor;\r\n\r\nuniform sampler2D uSampler;\r\n\r\nuniform float distance;\r\nuniform float outerStrength;\r\nuniform float innerStrength;\r\nuniform vec4 glowColor;\r\nuniform vec4 filterArea;\r\nuniform vec4 filterClamp;\r\nconst float PI = 3.14159265358979323846264;\r\n\r\nvoid main(void) {\r\n    vec2 px = vec2(1.0 / filterArea.x, 1.0 / filterArea.y);\r\n    vec4 ownColor = texture2D(uSampler, vTextureCoord);\r\n    vec4 curColor;\r\n    float totalAlpha = 0.0;\r\n    float maxTotalAlpha = 0.0;\r\n    float cosAngle;\r\n    float sinAngle;\r\n    vec2 displaced;\r\n    for (float angle = 0.0; angle <= PI * 2.0; angle += %QUALITY_DIST%) {\r\n       cosAngle = cos(angle);\r\n       sinAngle = sin(angle);\r\n       for (float curDistance = 1.0; curDistance <= %DIST%; curDistance++) {\r\n           displaced.x = vTextureCoord.x + cosAngle * curDistance * px.x;\r\n           displaced.y = vTextureCoord.y + sinAngle * curDistance * px.y;\r\n           curColor = texture2D(uSampler, clamp(displaced, filterClamp.xy, filterClamp.zw));\r\n           totalAlpha += (distance - curDistance) * curColor.a;\r\n           maxTotalAlpha += (distance - curDistance);\r\n       }\r\n    }\r\n    maxTotalAlpha = max(maxTotalAlpha, 0.0001);\r\n\r\n    ownColor.a = max(ownColor.a, 0.0001);\r\n    ownColor.rgb = ownColor.rgb / ownColor.a;\r\n    float outerGlowAlpha = (totalAlpha / maxTotalAlpha)  * outerStrength * (1. - ownColor.a);\r\n    float innerGlowAlpha = ((maxTotalAlpha - totalAlpha) / maxTotalAlpha) * innerStrength * ownColor.a;\r\n    float resultAlpha = (ownColor.a + outerGlowAlpha);\r\n    gl_FragColor = vec4(mix(mix(ownColor.rgb, glowColor.rgb, innerGlowAlpha / ownColor.a), glowColor.rgb, outerGlowAlpha / resultAlpha) * resultAlpha, resultAlpha);\r\n}\r\n",nr=function(r){function t(e,t,n,o,i){void 0===e&&(e=10),void 0===t&&(t=4),void 0===n&&(n=0),void 0===o&&(o=16777215),void 0===i&&(i=.1),r.call(this,er,tr.replace(/%QUALITY_DIST%/gi,""+(1/i/e).toFixed(7)).replace(/%DIST%/gi,""+e.toFixed(7))),this.uniforms.glowColor=new Float32Array([0,0,0,1]),this.distance=e,this.color=o,this.outerStrength=t,this.innerStrength=n}r&&(t.__proto__=r),t.prototype=Object.create(r&&r.prototype),t.prototype.constructor=t;var n={color:{configurable:!0},distance:{configurable:!0},outerStrength:{configurable:!0},innerStrength:{configurable:!0}};return n.color.get=function(){return e.utils.rgb2hex(this.uniforms.glowColor)},n.color.set=function(r){e.utils.hex2rgb(r,this.uniforms.glowColor)},n.distance.get=function(){return this.uniforms.distance},n.distance.set=function(r){this.uniforms.distance=r},n.outerStrength.get=function(){return this.uniforms.outerStrength},n.outerStrength.set=function(r){this.uniforms.outerStrength=r},n.innerStrength.get=function(){return this.uniforms.innerStrength},n.innerStrength.set=function(r){this.uniforms.innerStrength=r},Object.defineProperties(t.prototype,n),t}(e.Filter),or="attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n    vTextureCoord = aTextureCoord;\r\n}",ir="vec3 mod289(vec3 x)\r\n{\r\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\r\n}\r\nvec4 mod289(vec4 x)\r\n{\r\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\r\n}\r\nvec4 permute(vec4 x)\r\n{\r\n    return mod289(((x * 34.0) + 1.0) * x);\r\n}\r\nvec4 taylorInvSqrt(vec4 r)\r\n{\r\n    return 1.79284291400159 - 0.85373472095314 * r;\r\n}\r\nvec3 fade(vec3 t)\r\n{\r\n    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\r\n}\r\n// Classic Perlin noise, periodic variant\r\nfloat pnoise(vec3 P, vec3 rep)\r\n{\r\n    vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\r\n    vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\r\n    Pi0 = mod289(Pi0);\r\n    Pi1 = mod289(Pi1);\r\n    vec3 Pf0 = fract(P); // Fractional part for interpolation\r\n    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\r\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\r\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\r\n    vec4 iz0 = Pi0.zzzz;\r\n    vec4 iz1 = Pi1.zzzz;\r\n    vec4 ixy = permute(permute(ix) + iy);\r\n    vec4 ixy0 = permute(ixy + iz0);\r\n    vec4 ixy1 = permute(ixy + iz1);\r\n    vec4 gx0 = ixy0 * (1.0 / 7.0);\r\n    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\r\n    gx0 = fract(gx0);\r\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\r\n    vec4 sz0 = step(gz0, vec4(0.0));\r\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\r\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\r\n    vec4 gx1 = ixy1 * (1.0 / 7.0);\r\n    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\r\n    gx1 = fract(gx1);\r\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\r\n    vec4 sz1 = step(gz1, vec4(0.0));\r\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\r\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\r\n    vec3 g000 = vec3(gx0.x, gy0.x, gz0.x);\r\n    vec3 g100 = vec3(gx0.y, gy0.y, gz0.y);\r\n    vec3 g010 = vec3(gx0.z, gy0.z, gz0.z);\r\n    vec3 g110 = vec3(gx0.w, gy0.w, gz0.w);\r\n    vec3 g001 = vec3(gx1.x, gy1.x, gz1.x);\r\n    vec3 g101 = vec3(gx1.y, gy1.y, gz1.y);\r\n    vec3 g011 = vec3(gx1.z, gy1.z, gz1.z);\r\n    vec3 g111 = vec3(gx1.w, gy1.w, gz1.w);\r\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\r\n    g000 *= norm0.x;\r\n    g010 *= norm0.y;\r\n    g100 *= norm0.z;\r\n    g110 *= norm0.w;\r\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\r\n    g001 *= norm1.x;\r\n    g011 *= norm1.y;\r\n    g101 *= norm1.z;\r\n    g111 *= norm1.w;\r\n    float n000 = dot(g000, Pf0);\r\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\r\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\r\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\r\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\r\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\r\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\r\n    float n111 = dot(g111, Pf1);\r\n    vec3 fade_xyz = fade(Pf0);\r\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\r\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\r\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\r\n    return 2.2 * n_xyz;\r\n}\r\nfloat turb(vec3 P, vec3 rep, float lacunarity, float gain)\r\n{\r\n    float sum = 0.0;\r\n    float sc = 1.0;\r\n    float totalgain = 1.0;\r\n    for (float i = 0.0; i < 6.0; i++)\r\n    {\r\n        sum += totalgain * pnoise(P * sc, rep);\r\n        sc *= lacunarity;\r\n        totalgain *= gain;\r\n    }\r\n    return abs(sum);\r\n}\r\n",ar="varying vec2 vTextureCoord;\r\nuniform sampler2D uSampler;\r\nuniform vec4 filterArea;\r\nuniform vec2 dimensions;\r\n\r\nuniform vec2 light;\r\nuniform bool parallel;\r\nuniform float aspect;\r\n\r\nuniform float gain;\r\nuniform float lacunarity;\r\nuniform float time;\r\n\r\n${perlin}\r\n\r\nvoid main(void) {\r\n    vec2 coord = vTextureCoord * filterArea.xy / dimensions.xy;\r\n\r\n    float d;\r\n\r\n    if (parallel) {\r\n        float _cos = light.x;\r\n        float _sin = light.y;\r\n        d = (_cos * coord.x) + (_sin * coord.y * aspect);\r\n    } else {\r\n        float dx = coord.x - light.x / dimensions.x;\r\n        float dy = (coord.y - light.y / dimensions.y) * aspect;\r\n        float dis = sqrt(dx * dx + dy * dy) + 0.00001;\r\n        d = dy / dis;\r\n    }\r\n\r\n    vec3 dir = vec3(d, d, 0.0);\r\n\r\n    float noise = turb(dir + vec3(time, 0.0, 62.1 + time) * 0.05, vec3(480.0, 320.0, 480.0), lacunarity, gain);\r\n    noise = mix(noise, 0.0, 0.3);\r\n    //fade vertically.\r\n    vec4 mist = vec4(noise, noise, noise, 1.0) * (1.0 - coord.y);\r\n    mist.a = 1.0;\r\n\r\n    gl_FragColor = texture2D(uSampler, vTextureCoord) + mist;\r\n}\r\n",lr=function(r){function t(t){r.call(this,or,ar.replace("${perlin}",ir)),this.uniforms.dimensions=new Float32Array(2),"number"==typeof t&&(console.warn("GodrayFilter now uses options instead of (angle, gain, lacunarity, time)"),t={angle:t},void 0!==arguments[1]&&(t.gain=arguments[1]),void 0!==arguments[2]&&(t.lacunarity=arguments[2]),void 0!==arguments[3]&&(t.time=arguments[3])),t=Object.assign({angle:30,gain:.5,lacunarity:2.5,time:0,parallel:!0,center:[0,0]},t),this._angleLight=new e.Point,this.angle=t.angle,this.gain=t.gain,this.lacunarity=t.lacunarity,this.parallel=t.parallel,this.center=t.center,this.time=t.time}r&&(t.__proto__=r),t.prototype=Object.create(r&&r.prototype),t.prototype.constructor=t;var n={angle:{configurable:!0},gain:{configurable:!0},lacunarity:{configurable:!0}};return t.prototype.apply=function(r,e,t,n){var o=e.sourceFrame,i=o.width,a=o.height;this.uniforms.light=this.parallel?this._angleLight:this.center,this.uniforms.parallel=this.parallel,this.uniforms.dimensions[0]=i,this.uniforms.dimensions[1]=a,this.uniforms.aspect=a/i,this.uniforms.time=this.time,r.applyFilter(this,e,t,n)},n.angle.get=function(){return this._angle},n.angle.set=function(r){this._angle=r;var t=r*e.DEG_TO_RAD;this._angleLight.x=Math.cos(t),this._angleLight.y=Math.sin(t)},n.gain.get=function(){return this.uniforms.gain},n.gain.set=function(r){this.uniforms.gain=r},n.lacunarity.get=function(){return this.uniforms.lacunarity},n.lacunarity.set=function(r){this.uniforms.lacunarity=r},Object.defineProperties(t.prototype,n),t}(e.Filter),sr="attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n    vTextureCoord = aTextureCoord;\r\n}",ur="varying vec2 vTextureCoord;\r\nuniform sampler2D uSampler;\r\nuniform vec4 filterArea;\r\n\r\nuniform vec2 uVelocity;\r\nuniform int uKernelSize;\r\nuniform float uOffset;\r\n\r\nconst int MAX_KERNEL_SIZE = 2048;\r\n\r\n// Notice:\r\n// the perfect way:\r\n//    int kernelSize = min(uKernelSize, MAX_KERNELSIZE);\r\n// BUT in real use-case , uKernelSize < MAX_KERNELSIZE almost always.\r\n// So use uKernelSize directly.\r\n\r\nvoid main(void)\r\n{\r\n    vec4 color = texture2D(uSampler, vTextureCoord);\r\n\r\n    if (uKernelSize == 0)\r\n    {\r\n        gl_FragColor = color;\r\n        return;\r\n    }\r\n\r\n    vec2 velocity = uVelocity / filterArea.xy;\r\n    float offset = -uOffset / length(uVelocity) - 0.5;\r\n    int k = uKernelSize - 1;\r\n\r\n    for(int i = 0; i < MAX_KERNEL_SIZE - 1; i++) {\r\n        if (i == k) {\r\n            break;\r\n        }\r\n        vec2 bias = velocity * (float(i) / float(k) + offset);\r\n        color += texture2D(uSampler, vTextureCoord + bias);\r\n    }\r\n    gl_FragColor = color / float(uKernelSize);\r\n}\r\n",cr=function(r){function t(t,n,o){void 0===t&&(t=[0,0]),void 0===n&&(n=5),void 0===o&&(o=0),r.call(this,sr,ur),this.uniforms.uVelocity=new Float32Array(2),this._velocity=new e.ObservablePoint(this.velocityChanged,this),this.velocity=t,this.kernelSize=n,this.offset=o}r&&(t.__proto__=r),t.prototype=Object.create(r&&r.prototype),t.prototype.constructor=t;var n={velocity:{configurable:!0},offset:{configurable:!0}};return t.prototype.apply=function(r,e,t,n){var o=this.velocity,i=o.x,a=o.y;this.uniforms.uKernelSize=0!==i||0!==a?this.kernelSize:0,r.applyFilter(this,e,t,n)},n.velocity.set=function(r){Array.isArray(r)?this._velocity.set(r[0],r[1]):(r instanceof e.Point||r instanceof e.ObservablePoint)&&this._velocity.copy(r)},n.velocity.get=function(){return this._velocity},t.prototype.velocityChanged=function(){this.uniforms.uVelocity[0]=this._velocity.x,this.uniforms.uVelocity[1]=this._velocity.y},n.offset.set=function(r){this.uniforms.uOffset=r},n.offset.get=function(){return this.uniforms.uOffset},Object.defineProperties(t.prototype,n),t}(e.Filter),fr="attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n    vTextureCoord = aTextureCoord;\r\n}",dr="varying vec2 vTextureCoord;\r\nuniform sampler2D uSampler;\r\n\r\nuniform float epsilon;\r\n\r\nconst int MAX_COLORS = %maxColors%;\r\n\r\nuniform vec3 originalColors[MAX_COLORS];\r\nuniform vec3 targetColors[MAX_COLORS];\r\n\r\nvoid main(void)\r\n{\r\n    gl_FragColor = texture2D(uSampler, vTextureCoord);\r\n\r\n    float alpha = gl_FragColor.a;\r\n    if (alpha < 0.0001)\r\n    {\r\n      return;\r\n    }\r\n\r\n    vec3 color = gl_FragColor.rgb / alpha;\r\n\r\n    for(int i = 0; i < MAX_COLORS; i++)\r\n    {\r\n      vec3 origColor = originalColors[i];\r\n      if (origColor.r < 0.0)\r\n      {\r\n        break;\r\n      }\r\n      vec3 colorDiff = origColor - color;\r\n      if (length(colorDiff) < epsilon)\r\n      {\r\n        vec3 targetColor = targetColors[i];\r\n        gl_FragColor = vec4((targetColor + colorDiff) * alpha, alpha);\r\n        return;\r\n      }\r\n    }\r\n}\r\n",pr=function(r){function t(e,t,n){void 0===t&&(t=.05),void 0===n&&(n=null),n=n||e.length,r.call(this,fr,dr.replace(/%maxColors%/g,n)),this.epsilon=t,this._maxColors=n,this._replacements=null,this.uniforms.originalColors=new Float32Array(3*n),this.uniforms.targetColors=new Float32Array(3*n),this.replacements=e}r&&(t.__proto__=r),t.prototype=Object.create(r&&r.prototype),t.prototype.constructor=t;var n={replacements:{configurable:!0},maxColors:{configurable:!0},epsilon:{configurable:!0}};return n.replacements.set=function(r){var t=this.uniforms.originalColors,n=this.uniforms.targetColors,o=r.length;if(o>this._maxColors)throw"Length of replacements ("+o+") exceeds the maximum colors length ("+this._maxColors+")";t[3*o]=-1;for(var i=0;i<o;i++){var a=r[i],l=a[0];"number"==typeof l?l=e.utils.hex2rgb(l):a[0]=e.utils.rgb2hex(l),t[3*i]=l[0],t[3*i+1]=l[1],t[3*i+2]=l[2];var s=a[1];"number"==typeof s?s=e.utils.hex2rgb(s):a[1]=e.utils.rgb2hex(s),n[3*i]=s[0],n[3*i+1]=s[1],n[3*i+2]=s[2]}this._replacements=r},n.replacements.get=function(){return this._replacements},t.prototype.refresh=function(){this.replacements=this._replacements},n.maxColors.get=function(){return this._maxColors},n.epsilon.set=function(r){this.uniforms.epsilon=r},n.epsilon.get=function(){return this.uniforms.epsilon},Object.defineProperties(t.prototype,n),t}(e.Filter),hr="attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n    vTextureCoord = aTextureCoord;\r\n}",mr="varying vec2 vTextureCoord;\r\nuniform sampler2D uSampler;\r\nuniform vec4 filterArea;\r\nuniform vec2 dimensions;\r\n\r\nuniform float sepia;\r\nuniform float noise;\r\nuniform float noiseSize;\r\nuniform float scratch;\r\nuniform float scratchDensity;\r\nuniform float scratchWidth;\r\nuniform float vignetting;\r\nuniform float vignettingAlpha;\r\nuniform float vignettingBlur;\r\nuniform float seed;\r\n\r\nconst float SQRT_2 = 1.414213;\r\nconst vec3 SEPIA_RGB = vec3(112.0 / 255.0, 66.0 / 255.0, 20.0 / 255.0);\r\n\r\nfloat rand(vec2 co) {\r\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\r\n}\r\n\r\nvec3 Overlay(vec3 src, vec3 dst)\r\n{\r\n    // if (dst <= 0.5) then: 2 * src * dst\r\n    // if (dst > 0.5) then: 1 - 2 * (1 - dst) * (1 - src)\r\n    return vec3((dst.x <= 0.5) ? (2.0 * src.x * dst.x) : (1.0 - 2.0 * (1.0 - dst.x) * (1.0 - src.x)),\r\n                (dst.y <= 0.5) ? (2.0 * src.y * dst.y) : (1.0 - 2.0 * (1.0 - dst.y) * (1.0 - src.y)),\r\n                (dst.z <= 0.5) ? (2.0 * src.z * dst.z) : (1.0 - 2.0 * (1.0 - dst.z) * (1.0 - src.z)));\r\n}\r\n\r\n\r\nvoid main()\r\n{\r\n    gl_FragColor = texture2D(uSampler, vTextureCoord);\r\n    vec3 color = gl_FragColor.rgb;\r\n\r\n    if (sepia > 0.0)\r\n    {\r\n        float gray = (color.x + color.y + color.z) / 3.0;\r\n        vec3 grayscale = vec3(gray);\r\n\r\n        color = Overlay(SEPIA_RGB, grayscale);\r\n\r\n        color = grayscale + sepia * (color - grayscale);\r\n    }\r\n\r\n    vec2 coord = vTextureCoord * filterArea.xy / dimensions.xy;\r\n\r\n    if (vignetting > 0.0)\r\n    {\r\n        float outter = SQRT_2 - vignetting * SQRT_2;\r\n        vec2 dir = vec2(vec2(0.5, 0.5) - coord);\r\n        dir.y *= dimensions.y / dimensions.x;\r\n        float darker = clamp((outter - length(dir) * SQRT_2) / ( 0.00001 + vignettingBlur * SQRT_2), 0.0, 1.0);\r\n        color.rgb *= darker + (1.0 - darker) * (1.0 - vignettingAlpha);\r\n    }\r\n\r\n    if (scratchDensity > seed && scratch != 0.0)\r\n    {\r\n        float phase = seed * 256.0;\r\n        float s = mod(floor(phase), 2.0);\r\n        float dist = 1.0 / scratchDensity;\r\n        float d = distance(coord, vec2(seed * dist, abs(s - seed * dist)));\r\n        if (d < seed * 0.6 + 0.4)\r\n        {\r\n            highp float period = scratchDensity * 10.0;\r\n\r\n            float xx = coord.x * period + phase;\r\n            float aa = abs(mod(xx, 0.5) * 4.0);\r\n            float bb = mod(floor(xx / 0.5), 2.0);\r\n            float yy = (1.0 - bb) * aa + bb * (2.0 - aa);\r\n\r\n            float kk = 2.0 * period;\r\n            float dw = scratchWidth / dimensions.x * (0.75 + seed);\r\n            float dh = dw * kk;\r\n\r\n            float tine = (yy - (2.0 - dh));\r\n\r\n            if (tine > 0.0) {\r\n                float _sign = sign(scratch);\r\n\r\n                tine = s * tine / period + scratch + 0.1;\r\n                tine = clamp(tine + 1.0, 0.5 + _sign * 0.5, 1.5 + _sign * 0.5);\r\n\r\n                color.rgb *= tine;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (noise > 0.0 && noiseSize > 0.0)\r\n    {\r\n        vec2 pixelCoord = vTextureCoord.xy * filterArea.xy;\r\n        pixelCoord.x = floor(pixelCoord.x / noiseSize);\r\n        pixelCoord.y = floor(pixelCoord.y / noiseSize);\r\n        // vec2 d = pixelCoord * noiseSize * vec2(1024.0 + seed * 512.0, 1024.0 - seed * 512.0);\r\n        // float _noise = snoise(d) * 0.5;\r\n        float _noise = rand(pixelCoord * noiseSize * seed) - 0.5;\r\n        color += _noise * noise;\r\n    }\r\n\r\n    gl_FragColor.rgb = color;\r\n}\r\n",gr=function(r){function e(e,t){void 0===t&&(t=0),r.call(this,hr,mr),this.uniforms.dimensions=new Float32Array(2),"number"==typeof e?(this.seed=e,e=null):this.seed=t,Object.assign(this,{sepia:.3,noise:.3,noiseSize:1,scratch:.5,scratchDensity:.3,scratchWidth:1,vignetting:.3,vignettingAlpha:1,vignettingBlur:.3},e)}r&&(e.__proto__=r),e.prototype=Object.create(r&&r.prototype),e.prototype.constructor=e;var t={sepia:{configurable:!0},noise:{configurable:!0},noiseSize:{configurable:!0},scratch:{configurable:!0},scratchDensity:{configurable:!0},scratchWidth:{configurable:!0},vignetting:{configurable:!0},vignettingAlpha:{configurable:!0},vignettingBlur:{configurable:!0}};return e.prototype.apply=function(r,e,t,n){this.uniforms.dimensions[0]=e.sourceFrame.width,this.uniforms.dimensions[1]=e.sourceFrame.height,this.uniforms.seed=this.seed,r.applyFilter(this,e,t,n)},t.sepia.set=function(r){this.uniforms.sepia=r},t.sepia.get=function(){return this.uniforms.sepia},t.noise.set=function(r){this.uniforms.noise=r},t.noise.get=function(){return this.uniforms.noise},t.noiseSize.set=function(r){this.uniforms.noiseSize=r},t.noiseSize.get=function(){return this.uniforms.noiseSize},t.scratch.set=function(r){this.uniforms.scratch=r},t.scratch.get=function(){return this.uniforms.scratch},t.scratchDensity.set=function(r){this.uniforms.scratchDensity=r},t.scratchDensity.get=function(){return this.uniforms.scratchDensity},t.scratchWidth.set=function(r){this.uniforms.scratchWidth=r},t.scratchWidth.get=function(){return this.uniforms.scratchWidth},t.vignetting.set=function(r){this.uniforms.vignetting=r},t.vignetting.get=function(){return this.uniforms.vignetting},t.vignettingAlpha.set=function(r){this.uniforms.vignettingAlpha=r},t.vignettingAlpha.get=function(){return this.uniforms.vignettingAlpha},t.vignettingBlur.set=function(r){this.uniforms.vignettingBlur=r},t.vignettingBlur.get=function(){return this.uniforms.vignettingBlur},Object.defineProperties(e.prototype,t),e}(e.Filter),vr="attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n    vTextureCoord = aTextureCoord;\r\n}",xr="varying vec2 vTextureCoord;\r\nuniform sampler2D uSampler;\r\n\r\nuniform vec2 thickness;\r\nuniform vec4 outlineColor;\r\nuniform vec4 filterClamp;\r\n\r\nconst float DOUBLE_PI = 3.14159265358979323846264 * 2.;\r\n\r\nvoid main(void) {\r\n    vec4 ownColor = texture2D(uSampler, vTextureCoord);\r\n    vec4 curColor;\r\n    float maxAlpha = 0.;\r\n    vec2 displaced;\r\n    for (float angle = 0.; angle <= DOUBLE_PI; angle += ${angleStep}) {\r\n        displaced.x = vTextureCoord.x + thickness.x * cos(angle);\r\n        displaced.y = vTextureCoord.y + thickness.y * sin(angle);\r\n        curColor = texture2D(uSampler, clamp(displaced, filterClamp.xy, filterClamp.zw));\r\n        maxAlpha = max(maxAlpha, curColor.a);\r\n    }\r\n    float resultAlpha = max(maxAlpha, ownColor.a);\r\n    gl_FragColor = vec4((ownColor.rgb + outlineColor.rgb * (1. - ownColor.a)) * resultAlpha, resultAlpha);\r\n}\r\n",yr=function(r){function t(e,n,o){void 0===e&&(e=1),void 0===n&&(n=0),void 0===o&&(o=.1);var i=Math.max(o*t.MAX_SAMPLES,t.MIN_SAMPLES),a=(2*Math.PI/i).toFixed(7);r.call(this,vr,xr.replace(/\$\{angleStep\}/,a)),this.uniforms.thickness=new Float32Array([0,0]),this.thickness=e,this.uniforms.outlineColor=new Float32Array([0,0,0,1]),this.color=n,this.quality=o}r&&(t.__proto__=r),t.prototype=Object.create(r&&r.prototype),t.prototype.constructor=t;var n={color:{configurable:!0}};return t.prototype.apply=function(r,e,t,n){this.uniforms.thickness[0]=this.thickness/e.size.width,this.uniforms.thickness[1]=this.thickness/e.size.height,r.applyFilter(this,e,t,n)},n.color.get=function(){return e.utils.rgb2hex(this.uniforms.outlineColor)},n.color.set=function(r){e.utils.hex2rgb(r,this.uniforms.outlineColor)},Object.defineProperties(t.prototype,n),t}(e.Filter);yr.MIN_SAMPLES=1,yr.MAX_SAMPLES=100;var br="attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n    vTextureCoord = aTextureCoord;\r\n}",_r="precision mediump float;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nuniform vec2 size;\r\nuniform sampler2D uSampler;\r\n\r\nuniform vec4 filterArea;\r\n\r\nvec2 mapCoord( vec2 coord )\r\n{\r\n    coord *= filterArea.xy;\r\n    coord += filterArea.zw;\r\n\r\n    return coord;\r\n}\r\n\r\nvec2 unmapCoord( vec2 coord )\r\n{\r\n    coord -= filterArea.zw;\r\n    coord /= filterArea.xy;\r\n\r\n    return coord;\r\n}\r\n\r\nvec2 pixelate(vec2 coord, vec2 size)\r\n{\r\n\treturn floor( coord / size ) * size;\r\n}\r\n\r\nvoid main(void)\r\n{\r\n    vec2 coord = mapCoord(vTextureCoord);\r\n\r\n    coord = pixelate(coord, size);\r\n\r\n    coord = unmapCoord(coord);\r\n\r\n    gl_FragColor = texture2D(uSampler, coord);\r\n}\r\n",Cr=function(r){function e(e){void 0===e&&(e=10),r.call(this,br,_r),this.size=e}r&&(e.__proto__=r),e.prototype=Object.create(r&&r.prototype),e.prototype.constructor=e;var t={size:{configurable:!0}};return t.size.get=function(){return this.uniforms.size},t.size.set=function(r){"number"==typeof r&&(r=[r,r]),this.uniforms.size=r},Object.defineProperties(e.prototype,t),e}(e.Filter),Sr="attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n    vTextureCoord = aTextureCoord;\r\n}",Tr="varying vec2 vTextureCoord;\r\nuniform sampler2D uSampler;\r\nuniform vec4 filterArea;\r\n\r\nuniform float uRadian;\r\nuniform vec2 uCenter;\r\nuniform float uRadius;\r\nuniform int uKernelSize;\r\n\r\nconst int MAX_KERNEL_SIZE = 2048;\r\n\r\nvoid main(void)\r\n{\r\n    vec4 color = texture2D(uSampler, vTextureCoord);\r\n\r\n    if (uKernelSize == 0)\r\n    {\r\n        gl_FragColor = color;\r\n        return;\r\n    }\r\n\r\n    float aspect = filterArea.y / filterArea.x;\r\n    vec2 center = uCenter.xy / filterArea.xy;\r\n    float gradient = uRadius / filterArea.x * 0.3;\r\n    float radius = uRadius / filterArea.x - gradient * 0.5;\r\n    int k = uKernelSize - 1;\r\n\r\n    vec2 coord = vTextureCoord;\r\n    vec2 dir = vec2(center - coord);\r\n    float dist = length(vec2(dir.x, dir.y * aspect));\r\n\r\n    float radianStep = uRadian;\r\n    if (radius >= 0.0 && dist > radius) {\r\n        float delta = dist - radius;\r\n        float gap = gradient;\r\n        float scale = 1.0 - abs(delta / gap);\r\n        if (scale <= 0.0) {\r\n            gl_FragColor = color;\r\n            return;\r\n        }\r\n        radianStep *= scale;\r\n    }\r\n    radianStep /= float(k);\r\n\r\n    float s = sin(radianStep);\r\n    float c = cos(radianStep);\r\n    mat2 rotationMatrix = mat2(vec2(c, -s), vec2(s, c));\r\n\r\n    for(int i = 0; i < MAX_KERNEL_SIZE - 1; i++) {\r\n        if (i == k) {\r\n            break;\r\n        }\r\n\r\n        coord -= center;\r\n        coord.y *= aspect;\r\n        coord = rotationMatrix * coord;\r\n        coord.y /= aspect;\r\n        coord += center;\r\n\r\n        vec4 sample = texture2D(uSampler, coord);\r\n\r\n        // switch to pre-multiplied alpha to correctly blur transparent images\r\n        // sample.rgb *= sample.a;\r\n\r\n        color += sample;\r\n    }\r\n\r\n    gl_FragColor = color / float(uKernelSize);\r\n}\r\n",Fr=function(r){function e(e,t,n,o){void 0===e&&(e=0),void 0===t&&(t=[0,0]),void 0===n&&(n=5),void 0===o&&(o=-1),r.call(this,Sr,Tr),this._angle=0,this.angle=e,this.center=t,this.kernelSize=n,this.radius=o}r&&(e.__proto__=r),e.prototype=Object.create(r&&r.prototype),e.prototype.constructor=e;var t={angle:{configurable:!0},center:{configurable:!0},radius:{configurable:!0}};return e.prototype.apply=function(r,e,t,n){this.uniforms.uKernelSize=0!==this._angle?this.kernelSize:0,r.applyFilter(this,e,t,n)},t.angle.set=function(r){this._angle=r,this.uniforms.uRadian=r*Math.PI/180},t.angle.get=function(){return this._angle},t.center.get=function(){return this.uniforms.uCenter},t.center.set=function(r){this.uniforms.uCenter=r},t.radius.get=function(){return this.uniforms.uRadius},t.radius.set=function(r){(r<0||r===1/0)&&(r=-1),this.uniforms.uRadius=r},Object.defineProperties(e.prototype,t),e}(e.Filter),zr="attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n    vTextureCoord = aTextureCoord;\r\n}",Ar="varying vec2 vTextureCoord;\r\nuniform sampler2D uSampler;\r\n\r\nuniform vec4 filterArea;\r\nuniform vec4 filterClamp;\r\nuniform vec2 dimensions;\r\n\r\nuniform bool mirror;\r\nuniform float boundary;\r\nuniform vec2 amplitude;\r\nuniform vec2 waveLength;\r\nuniform vec2 alpha;\r\nuniform float time;\r\n\r\nfloat rand(vec2 co) {\r\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\r\n}\r\n\r\nvoid main(void)\r\n{\r\n    vec2 pixelCoord = vTextureCoord.xy * filterArea.xy;\r\n    vec2 coord = pixelCoord / dimensions;\r\n\r\n    if (coord.y < boundary) {\r\n        gl_FragColor = texture2D(uSampler, vTextureCoord);\r\n        return;\r\n    }\r\n\r\n    float k = (coord.y - boundary) / (1. - boundary + 0.0001);\r\n    float areaY = boundary * dimensions.y / filterArea.y;\r\n    float v = areaY + areaY - vTextureCoord.y;\r\n    float y = mirror ? v : vTextureCoord.y;\r\n\r\n    float _amplitude = ((amplitude.y - amplitude.x) * k + amplitude.x ) / filterArea.x;\r\n    float _waveLength = ((waveLength.y - waveLength.x) * k + waveLength.x) / filterArea.y;\r\n    float _alpha = (alpha.y - alpha.x) * k + alpha.x;\r\n\r\n    float x = vTextureCoord.x + cos(v * 6.28 / _waveLength - time) * _amplitude;\r\n    x = clamp(x, filterClamp.x, filterClamp.z);\r\n\r\n    vec4 color = texture2D(uSampler, vec2(x, y));\r\n\r\n    gl_FragColor = color * _alpha;\r\n}\r\n",wr=function(r){function e(e){r.call(this,zr,Ar),this.uniforms.amplitude=new Float32Array(2),this.uniforms.waveLength=new Float32Array(2),this.uniforms.alpha=new Float32Array(2),this.uniforms.dimensions=new Float32Array(2),Object.assign(this,{mirror:!0,boundary:.5,amplitude:[0,20],waveLength:[30,100],alpha:[1,1],time:0},e)}r&&(e.__proto__=r),e.prototype=Object.create(r&&r.prototype),e.prototype.constructor=e;var t={mirror:{configurable:!0},boundary:{configurable:!0},amplitude:{configurable:!0},waveLength:{configurable:!0},alpha:{configurable:!0}};return e.prototype.apply=function(r,e,t,n){this.uniforms.dimensions[0]=e.sourceFrame.width,this.uniforms.dimensions[1]=e.sourceFrame.height,this.uniforms.time=this.time,r.applyFilter(this,e,t,n)},t.mirror.set=function(r){this.uniforms.mirror=r},t.mirror.get=function(){return this.uniforms.mirror},t.boundary.set=function(r){this.uniforms.boundary=r},t.boundary.get=function(){return this.uniforms.boundary},t.amplitude.set=function(r){this.uniforms.amplitude[0]=r[0],this.uniforms.amplitude[1]=r[1]},t.amplitude.get=function(){return this.uniforms.amplitude},t.waveLength.set=function(r){this.uniforms.waveLength[0]=r[0],this.uniforms.waveLength[1]=r[1]},t.waveLength.get=function(){return this.uniforms.waveLength},t.alpha.set=function(r){this.uniforms.alpha[0]=r[0],this.uniforms.alpha[1]=r[1]},t.alpha.get=function(){return this.uniforms.alpha},Object.defineProperties(e.prototype,t),e}(e.Filter),Pr="attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n    vTextureCoord = aTextureCoord;\r\n}",Dr="precision mediump float;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nuniform sampler2D uSampler;\r\nuniform vec4 filterArea;\r\nuniform vec2 red;\r\nuniform vec2 green;\r\nuniform vec2 blue;\r\n\r\nvoid main(void)\r\n{\r\n   gl_FragColor.r = texture2D(uSampler, vTextureCoord + red/filterArea.xy).r;\r\n   gl_FragColor.g = texture2D(uSampler, vTextureCoord + green/filterArea.xy).g;\r\n   gl_FragColor.b = texture2D(uSampler, vTextureCoord + blue/filterArea.xy).b;\r\n   gl_FragColor.a = texture2D(uSampler, vTextureCoord).a;\r\n}\r\n",Mr=function(r){function e(e,t,n){void 0===e&&(e=[-10,0]),void 0===t&&(t=[0,10]),void 0===n&&(n=[0,0]),r.call(this,Pr,Dr),this.red=e,this.green=t,this.blue=n}r&&(e.__proto__=r),e.prototype=Object.create(r&&r.prototype),e.prototype.constructor=e;var t={red:{configurable:!0},green:{configurable:!0},blue:{configurable:!0}};return t.red.get=function(){return this.uniforms.red},t.red.set=function(r){this.uniforms.red=r},t.green.get=function(){return this.uniforms.green},t.green.set=function(r){this.uniforms.green=r},t.blue.get=function(){return this.uniforms.blue},t.blue.set=function(r){this.uniforms.blue=r},Object.defineProperties(e.prototype,t),e}(e.Filter),Or="attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n    vTextureCoord = aTextureCoord;\r\n}",jr="varying vec2 vTextureCoord;\r\nuniform sampler2D uSampler;\r\nuniform vec4 filterArea;\r\nuniform vec4 filterClamp;\r\n\r\nuniform vec2 center;\r\n\r\nuniform float amplitude;\r\nuniform float wavelength;\r\n// uniform float power;\r\nuniform float brightness;\r\nuniform float speed;\r\nuniform float radius;\r\n\r\nuniform float time;\r\n\r\nconst float PI = 3.14159;\r\n\r\nvoid main()\r\n{\r\n    float halfWavelength = wavelength * 0.5 / filterArea.x;\r\n    float maxRadius = radius / filterArea.x;\r\n    float currentRadius = time * speed / filterArea.x;\r\n\r\n    float fade = 1.0;\r\n\r\n    if (maxRadius > 0.0) {\r\n        if (currentRadius > maxRadius) {\r\n            gl_FragColor = texture2D(uSampler, vTextureCoord);\r\n            return;\r\n        }\r\n        fade = 1.0 - pow(currentRadius / maxRadius, 2.0);\r\n    }\r\n\r\n    vec2 dir = vec2(vTextureCoord - center / filterArea.xy);\r\n    dir.y *= filterArea.y / filterArea.x;\r\n    float dist = length(dir);\r\n\r\n    if (dist <= 0.0 || dist < currentRadius - halfWavelength || dist > currentRadius + halfWavelength) {\r\n        gl_FragColor = texture2D(uSampler, vTextureCoord);\r\n        return;\r\n    }\r\n\r\n    vec2 diffUV = normalize(dir);\r\n\r\n    float diff = (dist - currentRadius) / halfWavelength;\r\n\r\n    float p = 1.0 - pow(abs(diff), 2.0);\r\n\r\n    // float powDiff = diff * pow(p, 2.0) * ( amplitude * fade );\r\n    float powDiff = 1.25 * sin(diff * PI) * p * ( amplitude * fade );\r\n\r\n    vec2 offset = diffUV * powDiff / filterArea.xy;\r\n\r\n    // Do clamp :\r\n    vec2 coord = vTextureCoord + offset;\r\n    vec2 clampedCoord = clamp(coord, filterClamp.xy, filterClamp.zw);\r\n    vec4 color = texture2D(uSampler, clampedCoord);\r\n    if (coord != clampedCoord) {\r\n        color *= max(0.0, 1.0 - length(coord - clampedCoord));\r\n    }\r\n\r\n    // No clamp :\r\n    // gl_FragColor = texture2D(uSampler, vTextureCoord + offset);\r\n\r\n    color.rgb *= 1.0 + (brightness - 1.0) * p * fade;\r\n\r\n    gl_FragColor = color;\r\n}\r\n",Rr=function(r){function e(e,t,n){void 0===e&&(e=[0,0]),void 0===t&&(t={}),void 0===n&&(n=0),r.call(this,Or,jr),this.center=e,Array.isArray(t)&&(console.warn("Deprecated Warning: ShockwaveFilter params Array has been changed to options Object."),t={}),t=Object.assign({amplitude:30,wavelength:160,brightness:1,speed:500,radius:-1},t),this.amplitude=t.amplitude,this.wavelength=t.wavelength,this.brightness=t.brightness,this.speed=t.speed,this.radius=t.radius,this.time=n}r&&(e.__proto__=r),e.prototype=Object.create(r&&r.prototype),e.prototype.constructor=e;var t={center:{configurable:!0},amplitude:{configurable:!0},wavelength:{configurable:!0},brightness:{configurable:!0},speed:{configurable:!0},radius:{configurable:!0}};return e.prototype.apply=function(r,e,t,n){this.uniforms.time=this.time,r.applyFilter(this,e,t,n)},t.center.get=function(){return this.uniforms.center},t.center.set=function(r){this.uniforms.center=r},t.amplitude.get=function(){return this.uniforms.amplitude},t.amplitude.set=function(r){this.uniforms.amplitude=r},t.wavelength.get=function(){return this.uniforms.wavelength},t.wavelength.set=function(r){this.uniforms.wavelength=r},t.brightness.get=function(){return this.uniforms.brightness},t.brightness.set=function(r){this.uniforms.brightness=r},t.speed.get=function(){return this.uniforms.speed},t.speed.set=function(r){this.uniforms.speed=r},t.radius.get=function(){return this.uniforms.radius},t.radius.set=function(r){this.uniforms.radius=r},Object.defineProperties(e.prototype,t),e}(e.Filter),Lr="attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n    vTextureCoord = aTextureCoord;\r\n}",kr="varying vec2 vTextureCoord;\r\nuniform sampler2D uSampler;\r\nuniform sampler2D uLightmap;\r\nuniform vec4 filterArea;\r\nuniform vec2 dimensions;\r\nuniform vec4 ambientColor;\r\nvoid main() {\r\n    vec4 diffuseColor = texture2D(uSampler, vTextureCoord);\r\n    vec2 lightCoord = (vTextureCoord * filterArea.xy) / dimensions;\r\n    vec4 light = texture2D(uLightmap, lightCoord);\r\n    vec3 ambient = ambientColor.rgb * ambientColor.a;\r\n    vec3 intensity = ambient + light.rgb;\r\n    vec3 finalColor = diffuseColor.rgb * intensity;\r\n    gl_FragColor = vec4(finalColor, diffuseColor.a);\r\n}\r\n",Ir=function(r){function t(e,t,n){void 0===t&&(t=0),void 0===n&&(n=1),r.call(this,Lr,kr),this.uniforms.dimensions=new Float32Array(2),this.uniforms.ambientColor=new Float32Array([0,0,0,n]),this.texture=e,this.color=t}r&&(t.__proto__=r),t.prototype=Object.create(r&&r.prototype),t.prototype.constructor=t;var n={texture:{configurable:!0},color:{configurable:!0},alpha:{configurable:!0}};return t.prototype.apply=function(r,e,t,n){this.uniforms.dimensions[0]=e.sourceFrame.width,this.uniforms.dimensions[1]=e.sourceFrame.height,r.applyFilter(this,e,t,n)},n.texture.get=function(){return this.uniforms.uLightmap},n.texture.set=function(r){this.uniforms.uLightmap=r},n.color.set=function(r){var t=this.uniforms.ambientColor;"number"==typeof r?(e.utils.hex2rgb(r,t),this._color=r):(t[0]=r[0],t[1]=r[1],t[2]=r[2],t[3]=r[3],this._color=e.utils.rgb2hex(t))},n.color.get=function(){return this._color},n.alpha.get=function(){return this.uniforms.ambientColor[3]},n.alpha.set=function(r){this.uniforms.ambientColor[3]=r},Object.defineProperties(t.prototype,n),t}(e.Filter),Vr="attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n    vTextureCoord = aTextureCoord;\r\n}",Er="varying vec2 vTextureCoord;\r\n\r\nuniform sampler2D uSampler;\r\nuniform float blur;\r\nuniform float gradientBlur;\r\nuniform vec2 start;\r\nuniform vec2 end;\r\nuniform vec2 delta;\r\nuniform vec2 texSize;\r\n\r\nfloat random(vec3 scale, float seed)\r\n{\r\n    return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\r\n}\r\n\r\nvoid main(void)\r\n{\r\n    vec4 color = vec4(0.0);\r\n    float total = 0.0;\r\n\r\n    float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\r\n    vec2 normal = normalize(vec2(start.y - end.y, end.x - start.x));\r\n    float radius = smoothstep(0.0, 1.0, abs(dot(vTextureCoord * texSize - start, normal)) / gradientBlur) * blur;\r\n\r\n    for (float t = -30.0; t <= 30.0; t++)\r\n    {\r\n        float percent = (t + offset - 0.5) / 30.0;\r\n        float weight = 1.0 - abs(percent);\r\n        vec4 sample = texture2D(uSampler, vTextureCoord + delta / texSize * percent * radius);\r\n        sample.rgb *= sample.a;\r\n        color += sample * weight;\r\n        total += weight;\r\n    }\r\n\r\n    color /= total;\r\n    color.rgb /= color.a + 0.00001;\r\n\r\n    gl_FragColor = color;\r\n}\r\n",Br=function(r){function t(t,n,o,i){void 0===t&&(t=100),void 0===n&&(n=600),void 0===o&&(o=null),void 0===i&&(i=null),r.call(this,Vr,Er),this.uniforms.blur=t,this.uniforms.gradientBlur=n,this.uniforms.start=o||new e.Point(0,window.innerHeight/2),this.uniforms.end=i||new e.Point(600,window.innerHeight/2),this.uniforms.delta=new e.Point(30,30),this.uniforms.texSize=new e.Point(window.innerWidth,window.innerHeight),this.updateDelta()}r&&(t.__proto__=r),t.prototype=Object.create(r&&r.prototype),t.prototype.constructor=t;var n={blur:{configurable:!0},gradientBlur:{configurable:!0},start:{configurable:!0},end:{configurable:!0}};return t.prototype.updateDelta=function(){this.uniforms.delta.x=0,this.uniforms.delta.y=0},n.blur.get=function(){return this.uniforms.blur},n.blur.set=function(r){this.uniforms.blur=r},n.gradientBlur.get=function(){return this.uniforms.gradientBlur},n.gradientBlur.set=function(r){this.uniforms.gradientBlur=r},n.start.get=function(){return this.uniforms.start},n.start.set=function(r){this.uniforms.start=r,this.updateDelta()},n.end.get=function(){return this.uniforms.end},n.end.set=function(r){this.uniforms.end=r,this.updateDelta()},Object.defineProperties(t.prototype,n),t}(e.Filter),Xr=function(r){function e(){r.apply(this,arguments)}return r&&(e.__proto__=r),e.prototype=Object.create(r&&r.prototype),e.prototype.constructor=e,e.prototype.updateDelta=function(){var r=this.uniforms.end.x-this.uniforms.start.x,e=this.uniforms.end.y-this.uniforms.start.y,t=Math.sqrt(r*r+e*e);this.uniforms.delta.x=r/t,this.uniforms.delta.y=e/t},e}(Br),qr=function(r){function e(){r.apply(this,arguments)}return r&&(e.__proto__=r),e.prototype=Object.create(r&&r.prototype),e.prototype.constructor=e,e.prototype.updateDelta=function(){var r=this.uniforms.end.x-this.uniforms.start.x,e=this.uniforms.end.y-this.uniforms.start.y,t=Math.sqrt(r*r+e*e);this.uniforms.delta.x=-e/t,this.uniforms.delta.y=r/t},e}(Br),Nr=function(r){function e(e,t,n,o){void 0===e&&(e=100),void 0===t&&(t=600),void 0===n&&(n=null),void 0===o&&(o=null),r.call(this),this.tiltShiftXFilter=new Xr(e,t,n,o),this.tiltShiftYFilter=new qr(e,t,n,o)}r&&(e.__proto__=r),e.prototype=Object.create(r&&r.prototype),e.prototype.constructor=e;var t={blur:{configurable:!0},gradientBlur:{configurable:!0},start:{configurable:!0},end:{configurable:!0}};return e.prototype.apply=function(r,e,t){var n=r.getRenderTarget(!0);this.tiltShiftXFilter.apply(r,e,n),this.tiltShiftYFilter.apply(r,n,t),r.returnRenderTarget(n)},t.blur.get=function(){return this.tiltShiftXFilter.blur},t.blur.set=function(r){this.tiltShiftXFilter.blur=this.tiltShiftYFilter.blur=r},t.gradientBlur.get=function(){return this.tiltShiftXFilter.gradientBlur},t.gradientBlur.set=function(r){this.tiltShiftXFilter.gradientBlur=this.tiltShiftYFilter.gradientBlur=r},t.start.get=function(){return this.tiltShiftXFilter.start},t.start.set=function(r){this.tiltShiftXFilter.start=this.tiltShiftYFilter.start=r},t.end.get=function(){return this.tiltShiftXFilter.end},t.end.set=function(r){this.tiltShiftXFilter.end=this.tiltShiftYFilter.end=r},Object.defineProperties(e.prototype,t),e}(e.Filter),Gr="attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n    vTextureCoord = aTextureCoord;\r\n}",Kr="varying vec2 vTextureCoord;\r\n\r\nuniform sampler2D uSampler;\r\nuniform float radius;\r\nuniform float angle;\r\nuniform vec2 offset;\r\nuniform vec4 filterArea;\r\n\r\nvec2 mapCoord( vec2 coord )\r\n{\r\n    coord *= filterArea.xy;\r\n    coord += filterArea.zw;\r\n\r\n    return coord;\r\n}\r\n\r\nvec2 unmapCoord( vec2 coord )\r\n{\r\n    coord -= filterArea.zw;\r\n    coord /= filterArea.xy;\r\n\r\n    return coord;\r\n}\r\n\r\nvec2 twist(vec2 coord)\r\n{\r\n    coord -= offset;\r\n\r\n    float dist = length(coord);\r\n\r\n    if (dist < radius)\r\n    {\r\n        float ratioDist = (radius - dist) / radius;\r\n        float angleMod = ratioDist * ratioDist * angle;\r\n        float s = sin(angleMod);\r\n        float c = cos(angleMod);\r\n        coord = vec2(coord.x * c - coord.y * s, coord.x * s + coord.y * c);\r\n    }\r\n\r\n    coord += offset;\r\n\r\n    return coord;\r\n}\r\n\r\nvoid main(void)\r\n{\r\n\r\n    vec2 coord = mapCoord(vTextureCoord);\r\n\r\n    coord = twist(coord);\r\n\r\n    coord = unmapCoord(coord);\r\n\r\n    gl_FragColor = texture2D(uSampler, coord );\r\n\r\n}\r\n",Yr=function(r){function e(e,t,n){void 0===e&&(e=200),void 0===t&&(t=4),void 0===n&&(n=20),r.call(this,Gr,Kr),this.radius=e,this.angle=t,this.padding=n}r&&(e.__proto__=r),e.prototype=Object.create(r&&r.prototype),e.prototype.constructor=e;var t={offset:{configurable:!0},radius:{configurable:!0},angle:{configurable:!0}};return t.offset.get=function(){return this.uniforms.offset},t.offset.set=function(r){this.uniforms.offset=r},t.radius.get=function(){return this.uniforms.radius},t.radius.set=function(r){this.uniforms.radius=r},t.angle.get=function(){return this.uniforms.angle},t.angle.set=function(r){this.uniforms.angle=r},Object.defineProperties(e.prototype,t),e}(e.Filter),Wr="attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n    vTextureCoord = aTextureCoord;\r\n}",Qr="varying vec2 vTextureCoord;\r\nuniform sampler2D uSampler;\r\nuniform vec4 filterArea;\r\n\r\nuniform vec2 uCenter;\r\nuniform float uStrength;\r\nuniform float uInnerRadius;\r\nuniform float uRadius;\r\n\r\nconst float MAX_KERNEL_SIZE = 32.0;\r\n\r\nfloat random(vec3 scale, float seed) {\r\n    // use the fragment position for a different seed per-pixel\r\n    return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\r\n}\r\n\r\nvoid main() {\r\n\r\n    float minGradient = uInnerRadius * 0.3;\r\n    float innerRadius = (uInnerRadius + minGradient * 0.5) / filterArea.x;\r\n\r\n    float gradient = uRadius * 0.3;\r\n    float radius = (uRadius - gradient * 0.5) / filterArea.x;\r\n\r\n    float countLimit = MAX_KERNEL_SIZE;\r\n\r\n    vec2 dir = vec2(uCenter.xy / filterArea.xy - vTextureCoord);\r\n    float dist = length(vec2(dir.x, dir.y * filterArea.y / filterArea.x));\r\n\r\n    float strength = uStrength;\r\n\r\n    float delta = 0.0;\r\n    float gap;\r\n    if (dist < innerRadius) {\r\n        delta = innerRadius - dist;\r\n        gap = minGradient;\r\n    } else if (radius >= 0.0 && dist > radius) { // radius < 0 means it's infinity\r\n        delta = dist - radius;\r\n        gap = gradient;\r\n    }\r\n\r\n    if (delta > 0.0) {\r\n        float normalCount = gap / filterArea.x;\r\n        delta = (normalCount - delta) / normalCount;\r\n        countLimit *= delta;\r\n        strength *= delta;\r\n        if (countLimit < 1.0)\r\n        {\r\n            gl_FragColor = texture2D(uSampler, vTextureCoord);\r\n            return;\r\n        }\r\n    }\r\n\r\n    // randomize the lookup values to hide the fixed number of samples\r\n    float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\r\n\r\n    float total = 0.0;\r\n    vec4 color = vec4(0.0);\r\n\r\n    dir *= strength;\r\n\r\n    for (float t = 0.0; t < MAX_KERNEL_SIZE; t++) {\r\n        float percent = (t + offset) / MAX_KERNEL_SIZE;\r\n        float weight = 4.0 * (percent - percent * percent);\r\n        vec2 p = vTextureCoord + dir * percent;\r\n        vec4 sample = texture2D(uSampler, p);\r\n\r\n        // switch to pre-multiplied alpha to correctly blur transparent images\r\n        // sample.rgb *= sample.a;\r\n\r\n        color += sample * weight;\r\n        total += weight;\r\n\r\n        if (t > countLimit){\r\n            break;\r\n        }\r\n    }\r\n\r\n    color /= total;\r\n    // switch back from pre-multiplied alpha\r\n    color.rgb /= color.a + 0.00001;\r\n\r\n    gl_FragColor = color;\r\n}\r\n",Ur=function(r){function e(e,t,n,o){void 0===e&&(e=.1),void 0===t&&(t=[0,0]),void 0===n&&(n=0),void 0===o&&(o=-1),r.call(this,Wr,Qr),this.center=t,this.strength=e,this.innerRadius=n,this.radius=o}r&&(e.__proto__=r),e.prototype=Object.create(r&&r.prototype),e.prototype.constructor=e;var t={center:{configurable:!0},strength:{configurable:!0},innerRadius:{configurable:!0},radius:{configurable:!0}};return t.center.get=function(){return this.uniforms.uCenter},t.center.set=function(r){this.uniforms.uCenter=r},t.strength.get=function(){return this.uniforms.uStrength},t.strength.set=function(r){this.uniforms.uStrength=r},t.innerRadius.get=function(){return this.uniforms.uInnerRadius},t.innerRadius.set=function(r){this.uniforms.uInnerRadius=r},t.radius.get=function(){return this.uniforms.uRadius},t.radius.set=function(r){(r<0||r===1/0)&&(r=-1),this.uniforms.uRadius=r},Object.defineProperties(e.prototype,t),e}(e.Filter);return r.AdjustmentFilter=o,r.AdvancedBloomFilter=p,r.AsciiFilter=g,r.BevelFilter=y,r.BloomFilter=T,r.BulgePinchFilter=A,r.ColorMapFilter=D,r.ColorReplaceFilter=j,r.ConvolutionFilter=k,r.CrossHatchFilter=E,r.CRTFilter=q,r.DotFilter=K,r.DropShadowFilter=Q,r.EmbossFilter=H,r.GlitchFilter=rr,r.GlowFilter=nr,r.GodrayFilter=lr,r.KawaseBlurFilter=s,r.MotionBlurFilter=cr,r.MultiColorReplaceFilter=pr,r.OldFilmFilter=gr,r.OutlineFilter=yr,r.PixelateFilter=Cr,r.RadialBlurFilter=Fr,r.ReflectionFilter=wr,r.RGBSplitFilter=Mr,r.ShockwaveFilter=Rr,r.SimpleLightmapFilter=Ir,r.TiltShiftFilter=Nr,r.TiltShiftAxisFilter=Br,r.TiltShiftXFilter=Xr,r.TiltShiftYFilter=qr,r.TwistFilter=Yr,r.ZoomBlurFilter=Ur,r}({},PIXI);Object.assign(PIXI.filters,this?this.__filters:__filters);
//# sourceMappingURL=pixi-filters.js.map
